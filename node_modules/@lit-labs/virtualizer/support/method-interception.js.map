{"version":3,"file":"method-interception.js","sourceRoot":"","sources":["../src/support/method-interception.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAuBH;;;;;;;;;;;;GAYG;AACH,MAAM,UAAU,eAAe,CAK7B,MAAS,EACT,UAAa,EACb,WAAiC;IAEjC,MAAM,cAAc,GAAG,MAAM,CAAC,UAAU,CAA6B,CAAC;IACtE,MAAM,SAAS,GAAa,CAAC,GAAG,IAAe,EAAE,EAAE,CACjD,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,cAAc,EAAE,GAAI,IAAsB,CAAC,CAAC;IACvE,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,EAAC,CAAS,UAAU,CAAC,EAAE,SAAS,EAAC,CAAC,CAAC;IACzD,OAAO,GAAG,EAAE;QACV,IAAK,MAAM,CAAC,UAAU,CAA8B,KAAK,SAAS,EAAE,CAAC;YACnE,MAAM,IAAI,KAAK,CACb,sBACE,UACF,QAAQ,MAAM,sDAAsD,CACrE,CAAC;QACJ,CAAC;QACD,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,EAAC,CAAS,UAAU,CAAC,EAAE,cAAc,EAAC,CAAC,CAAC;QAC9D,OAAO,cAAmB,CAAC;IAC7B,CAAC,CAAC;AACJ,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport type AnyFunction = (...args: any[]) => any;\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n/**\n * An MethodInterceptor function is defined as accepting a function it is intercepting\n * or \"wrapping\" calls to.  It has the same signature as the original function, except\n * that it has an additional first argument that is the \"original\" or wrapped\n * function that may be called or not depending on the interceptor's logic.  The\n * approach is analagous to calling super() in a subclass's method.\n */\nexport type MethodInterceptor<T extends AnyFunction> = (\n  originalFunction: T | undefined,\n  ...args: Parameters<T>\n) => ReturnType<T>;\n\n/**\n * An InterceptorTeardown function reverses the effects of an interceptMethod().\n */\nexport type MethodInterceptorTeardown = () => void;\n\n/**\n * Replaces the method on the object with a new method that calls the interceptor\n * function along with the original function so the interceptor can decided how to\n * handle the call.  Essentially enables wrapping an existing method with new logic\n * similarly to how a subclass can call super() to invoke the superclass's method.\n * @param object The method's host object\n * @param methodName The name of the method to intercept/wrap\n * @param interceptor The interceptor function that is called when the method is\n *   called.  It is passed the original method as the first argument, followed by\n *   the original method's arguments.\n * @returns a teardown function that can be called to restore the original method\n *   to the object.\n */\nexport function interceptMethod<\n  T extends object,\n  K extends keyof T,\n  F extends AnyFunction,\n>(\n  target: T,\n  methodName: K,\n  interceptor: MethodInterceptor<F>\n): MethodInterceptorTeardown {\n  const originalMethod = target[methodName] as unknown as F | undefined;\n  const newMethod: Function = (...args: unknown[]) =>\n    interceptor.bind(target)(originalMethod, ...(args as Parameters<F>));\n  Object.assign(target, {[<string>methodName]: newMethod});\n  return () => {\n    if ((target[methodName] as unknown as F | undefined) !== newMethod) {\n      throw new Error(\n        `Unexpected method \"${\n          methodName as string\n        }\" on ${target} likely due to out-of-sequence interceptor teardown.`\n      );\n    }\n    Object.assign(target, {[<string>methodName]: originalMethod});\n    return originalMethod as F;\n  };\n}\n"]}