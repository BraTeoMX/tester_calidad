/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { ReactiveElement } from '@lit/reactive-element';
import { Context } from '../create-context.js';
/**
 * A property decorator that adds a ContextConsumer controller to the component
 * which will try and retrieve a value for the property via the Context API.
 *
 * @param context A Context identifier value created via `createContext`
 * @param subscribe An optional boolean which when true allows the value to be updated
 *   multiple times.
 *
 * @example
 *
 * ```ts
 * import {consume} from '@lit-labs/context';
 * import {loggerContext, Logger} from 'community-protocols/logger';
 *
 * class MyElement {
 *   @consume({context: loggerContext})
 *   logger?: Logger;
 *
 *   doThing() {
 *     this.logger!.log('thing was done');
 *   }
 * }
 * ```
 * @category Decorator
 */
export declare function consume<ValueType>({ context, subscribe, }: {
    context: Context<unknown, ValueType>;
    subscribe?: boolean;
}): ConsumerDecorator<ValueType>;
declare type ConsumerDecorator<ValueType> = {
    <K extends PropertyKey, Proto extends ReactiveElement>(protoOrDescriptor: Proto, name?: K): FieldMustMatchProvidedType<Proto, K, ValueType>;
};
declare type DecoratorReturn = void | any;
declare type FieldMustMatchProvidedType<Obj, Key extends PropertyKey, ProvidedType> = Obj extends Record<Key, infer ConsumingType> ? [
    ProvidedType
] extends [ConsumingType] ? DecoratorReturn : {
    message: 'provided type not assignable to consuming field';
    provided: ProvidedType;
    consuming: ConsumingType;
} : Obj extends Partial<Record<Key, infer ConsumingType>> ? [
    ProvidedType
] extends [ConsumingType | undefined] ? DecoratorReturn : {
    message: 'provided type not assignable to consuming field';
    provided: ProvidedType;
    consuming: ConsumingType | undefined;
} : DecoratorReturn;
export {};
//# sourceMappingURL=consume.d.ts.map