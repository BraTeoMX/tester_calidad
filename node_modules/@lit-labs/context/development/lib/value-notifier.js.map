{"version":3,"file":"value-notifier.js","sourceRoot":"","sources":["../../src/lib/value-notifier.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AASH;;;;;;;GAOG;AACH,MAAM,OAAO,aAAa;IAmBxB,YAAY,YAAgB;QAlBpB,cAAS,GAAsC,IAAI,GAAG,EAAE,CAAC;QAwBjE,oBAAe,GAAG,GAAS,EAAE;YAC3B,KAAK,MAAM,CAAC,QAAQ,EAAE,QAAQ,CAAC,IAAI,IAAI,CAAC,SAAS,EAAE;gBACjD,QAAQ,CAAC,IAAI,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;aACjC;QACH,CAAC,CAAC;QATA,IAAI,YAAY,KAAK,SAAS,EAAE;YAC9B,IAAI,CAAC,KAAK,GAAG,YAAY,CAAC;SAC3B;IACH,CAAC;IAnBD,IAAW,KAAK;QACd,OAAO,IAAI,CAAC,MAAM,CAAC;IACrB,CAAC;IACD,IAAW,KAAK,CAAC,CAAI;QACnB,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;IACnB,CAAC;IAEM,QAAQ,CAAC,CAAI,EAAE,KAAK,GAAG,KAAK;QACjC,MAAM,MAAM,GAAG,KAAK,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;QACnD,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;QAChB,IAAI,MAAM,EAAE;YACV,IAAI,CAAC,eAAe,EAAE,CAAC;SACxB;IACH,CAAC;IAcD,WAAW,CAAC,QAA4B,EAAE,SAAmB;QAC3D,IAAI,SAAS,EAAE;YACb,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;gBACjC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,EAAE,GAAG,EAAE;oBAChC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;gBAClC,CAAC,CAAC,CAAC;aACJ;YACD,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAE,CAAC;YAC/C,QAAQ,CAAC,IAAI,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;SAChC;aAAM;YACL,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACtB;IACH,CAAC;IAED,cAAc;QACZ,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,CAAC;IACzB,CAAC;CACF","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ContextCallback} from './context-request-event.js';\n\n/**\n * A disposer function\n */\ntype Disposer = () => void;\n\n/**\n * A simple class which stores a value, and triggers registered callbacks when the\n * value is changed via its setter.\n *\n * An implementor might use other observable patterns such as MobX or Redux to get\n * behavior like this. But this is a pretty minimal approach that will likely work\n * for a number of use cases.\n */\nexport class ValueNotifier<T> {\n  private disposers: Map<ContextCallback<T>, Disposer> = new Map();\n\n  private _value!: T;\n  public get value(): T {\n    return this._value;\n  }\n  public set value(v: T) {\n    this.setValue(v);\n  }\n\n  public setValue(v: T, force = false) {\n    const update = force || !Object.is(v, this._value);\n    this._value = v;\n    if (update) {\n      this.updateObservers();\n    }\n  }\n\n  constructor(defaultValue?: T) {\n    if (defaultValue !== undefined) {\n      this.value = defaultValue;\n    }\n  }\n\n  updateObservers = (): void => {\n    for (const [callback, disposer] of this.disposers) {\n      callback(this._value, disposer);\n    }\n  };\n\n  addCallback(callback: ContextCallback<T>, subscribe?: boolean): void {\n    if (subscribe) {\n      if (!this.disposers.has(callback)) {\n        this.disposers.set(callback, () => {\n          this.disposers.delete(callback);\n        });\n      }\n      const disposer = this.disposers.get(callback)!;\n      callback(this.value, disposer);\n    } else {\n      callback(this.value);\n    }\n  }\n\n  clearCallbacks(): void {\n    this.disposers.clear();\n  }\n}\n"]}