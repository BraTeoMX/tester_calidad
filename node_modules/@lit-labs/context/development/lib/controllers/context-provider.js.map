{"version":3,"file":"context-provider.js","sourceRoot":"","sources":["../../../src/lib/controllers/context-provider.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAIH,OAAO,EAAC,aAAa,EAAC,MAAM,sBAAsB,CAAC;AAanD,MAAM,OAAO,oBAEX,SAAQ,KAAK;IACb;;;OAGG;IACH,YAAmC,OAAU;QAC3C,KAAK,CAAC,kBAAkB,EAAE,EAAC,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,IAAI,EAAC,CAAC,CAAC;QAD1B,YAAO,GAAP,OAAO,CAAG;IAE7C,CAAC;CACF;AAOD;;;;;;;GAOG;AACH,MAAM,OAAO,eACX,SAAQ,aAA6B;IASrC,YACE,IAAqB,EACrB,gBAAgC,EAChC,YAA6B;QAE7B,KAAK,CACF,gBAA+B,CAAC,OAAO,KAAK,SAAS;YACpD,CAAC,CAAE,gBAA+B,CAAC,YAAY;YAC/C,CAAC,CAAC,YAAY,CACjB,CAAC;QAWG,qBAAgB,GAAG,CACxB,EAAkD,EAC5C,EAAE;YACR,iDAAiD;YACjD,wDAAwD;YACxD,sEAAsE;YACtE,wEAAwE;YACxE,yEAAyE;YACzE,4DAA4D;YAC5D,IAAI,EAAE,CAAC,OAAO,KAAK,IAAI,CAAC,OAAO,IAAI,EAAE,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,IAAI,EAAE;gBACrE,OAAO;aACR;YACD,EAAE,CAAC,eAAe,EAAE,CAAC;YACrB,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,QAAQ,EAAE,EAAE,CAAC,SAAS,CAAC,CAAC;QAC9C,CAAC,CAAC;QAxBA,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAK,gBAA+B,CAAC,OAAO,KAAK,SAAS,EAAE;YAC1D,IAAI,CAAC,OAAO,GAAI,gBAA+B,CAAC,OAAO,CAAC;SACzD;aAAM;YACL,IAAI,CAAC,OAAO,GAAG,gBAAqB,CAAC;SACtC;QACD,IAAI,CAAC,eAAe,EAAE,CAAC;QACvB,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IAChC,CAAC;IAkBO,eAAe;QACrB,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,iBAAiB,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;IACvE,CAAC;IAED,aAAa;QACX,mEAAmE;QACnE,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,IAAI,oBAAoB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;IAClE,CAAC;CACF","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ContextRequestEvent} from '../context-request-event.js';\nimport {Context, ContextType} from '../create-context.js';\nimport {ValueNotifier} from '../value-notifier.js';\nimport {ReactiveController, ReactiveElement} from 'lit';\n\ndeclare global {\n  interface HTMLElementEventMap {\n    /**\n     * A 'context-provider' event can be emitted by any element which hosts\n     * a context provider to indicate it is available for use.\n     */\n    'context-provider': ContextProviderEvent<Context<unknown, unknown>>;\n  }\n}\n\nexport class ContextProviderEvent<\n  C extends Context<unknown, unknown>\n> extends Event {\n  /**\n   *\n   * @param context the context which this provider can provide\n   */\n  public constructor(public readonly context: C) {\n    super('context-provider', {bubbles: true, composed: true});\n  }\n}\n\nexport interface Options<C extends Context<unknown, unknown>> {\n  context: C;\n  initialValue?: ContextType<C>;\n}\n\n/**\n * A ReactiveController which adds context provider behavior to a\n * custom element.\n *\n * This controller simply listens to the `context-request` event when\n * the host is connected to the DOM and registers the received callbacks\n * against its observable Context implementation.\n */\nexport class ContextProvider<T extends Context<unknown, unknown>>\n  extends ValueNotifier<ContextType<T>>\n  implements ReactiveController\n{\n  protected host: ReactiveElement;\n  private context: T;\n\n  constructor(host: ReactiveElement, options: Options<T>);\n  /** @deprecated Use new ContextProvider(host, options) */\n  constructor(host: ReactiveElement, context: T, initialValue?: ContextType<T>);\n  constructor(\n    host: ReactiveElement,\n    contextOrOptions: T | Options<T>,\n    initialValue?: ContextType<T>\n  ) {\n    super(\n      (contextOrOptions as Options<T>).context !== undefined\n        ? (contextOrOptions as Options<T>).initialValue\n        : initialValue\n    );\n    this.host = host;\n    if ((contextOrOptions as Options<T>).context !== undefined) {\n      this.context = (contextOrOptions as Options<T>).context;\n    } else {\n      this.context = contextOrOptions as T;\n    }\n    this.attachListeners();\n    this.host.addController(this);\n  }\n\n  public onContextRequest = (\n    ev: ContextRequestEvent<Context<unknown, unknown>>\n  ): void => {\n    // Only call the callback if the context matches.\n    // Also, in case an element is a consumer AND a provider\n    // of the same context, we want to avoid the element to self-register.\n    // The check on composedPath (as opposed to ev.target) is to cover cases\n    // where the consumer is in the shadowDom of the provider (in which case,\n    // event.target === this.host because of event retargeting).\n    if (ev.context !== this.context || ev.composedPath()[0] === this.host) {\n      return;\n    }\n    ev.stopPropagation();\n    this.addCallback(ev.callback, ev.subscribe);\n  };\n\n  private attachListeners() {\n    this.host.addEventListener('context-request', this.onContextRequest);\n  }\n\n  hostConnected(): void {\n    // emit an event to signal a provider is available for this context\n    this.host.dispatchEvent(new ContextProviderEvent(this.context));\n  }\n}\n"]}