{"version":3,"file":"mask-parser.js","sourceRoot":"","sources":["../../../src/components/mask-input/mask-parser.ts"],"names":[],"mappings":"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","sourcesContent":["interface MaskOptions {\n  format: string;\n  promptCharacter: string;\n}\n\nconst FLAGS = new Set('aACL09#&?');\nconst REGEX = new Map([\n  ['C', /(?!^$)/u], // Non-empty\n  ['&', /[^\\p{Separator}]/u], // Whitespace\n  ['a', /[\\p{Letter}\\d\\p{Separator}]/u], // Alphanumeric & whitespace\n  ['A', /[\\p{Letter}\\d]/u], // Alphanumeric\n  ['?', /[\\p{Letter}\\p{Separator}]/u], // Alpha & whitespace\n  ['L', /\\p{Letter}/u], // Alpha\n  ['0', /\\d/], // Numeric\n  ['9', /[\\d\\p{Separator}]/u], // Numeric & whitespace\n  ['#', /[\\d\\-+]/], // Numeric and sign\n]);\nconst REQUIRED = new Set('0#LA&');\n\nconst replaceIMENumbers = (string: string) => {\n  return string.replace(\n    /[０１２３４５６７８９]/g,\n    (num) =>\n      ({\n        '１': '1',\n        '２': '2',\n        '３': '3',\n        '４': '4',\n        '５': '5',\n        '６': '6',\n        '７': '7',\n        '８': '8',\n        '９': '9',\n        '０': '0',\n      })[num] as string\n  );\n};\n\nexport class MaskParser {\n  protected options!: MaskOptions;\n\n  constructor(\n    options: MaskOptions = { format: 'CCCCCCCCCC', promptCharacter: '_' }\n  ) {\n    this.options = options;\n    this.parseMaskLiterals();\n  }\n\n  protected literals = new Map<number, string>();\n  protected _escapedMask = '';\n\n  public get literalPositions() {\n    return Array.from(this.literals.keys());\n  }\n\n  public get escapedMask() {\n    return this._escapedMask;\n  }\n\n  public get mask() {\n    return this.options.format;\n  }\n\n  public set mask(value: string) {\n    this.options.format = value || this.options.format;\n    this.parseMaskLiterals();\n  }\n\n  public get prompt() {\n    return this.options.promptCharacter;\n  }\n\n  public set prompt(value: string) {\n    this.options.promptCharacter = value\n      ? value.substring(0, 1)\n      : this.options.promptCharacter;\n  }\n\n  protected parseMaskLiterals() {\n    this.literals.clear();\n    this._escapedMask = this.mask;\n\n    for (let i = 0, j = 0; i < this.mask.length; i++, j++) {\n      const [current, next] = [this.mask.charAt(i), this.mask.charAt(i + 1)];\n\n      if (current === '\\\\' && FLAGS.has(next)) {\n        this._escapedMask = this.replaceCharAt(this._escapedMask, j, '');\n        this.literals.set(j, next);\n        i++;\n      } else if (!FLAGS.has(current)) {\n        this.literals.set(j, current);\n      }\n    }\n  }\n\n  protected isPromptChar(char: string) {\n    return char === this.prompt;\n  }\n\n  protected replaceCharAt(string: string, pos: number, char: string) {\n    return `${string.substring(0, pos)}${char}${string.substring(pos + 1)}`;\n  }\n\n  protected validate(char: string, maskedChar: string) {\n    const regex = REGEX.get(maskedChar);\n    return regex ? regex.test(char) : false;\n  }\n\n  protected getNonLiteralPositions(mask = '') {\n    const positions = this.literalPositions;\n    const result = [];\n    const iter = Array.from(mask).entries();\n\n    for (const [pos, _] of iter) {\n      if (!positions.includes(pos)) {\n        result.push(pos);\n      }\n    }\n\n    return result;\n  }\n\n  protected getRequiredNonLiteralPositions(mask: string) {\n    const positions = this.literalPositions;\n    const result = [];\n    const iter = Array.from(mask).entries();\n\n    for (const [pos, char] of iter) {\n      if (REQUIRED.has(char) && !positions.includes(pos)) {\n        result.push(pos);\n      }\n    }\n\n    return result;\n  }\n\n  public getPreviousNonLiteralPosition(start: number) {\n    const positions = this.literalPositions;\n    for (let i = start; i > 0; i--) {\n      if (!positions.includes(i)) return i;\n    }\n    return start;\n  }\n\n  public getNextNonLiteralPosition(start: number) {\n    const positions = this.literalPositions;\n    for (let i = start; i < this._escapedMask.length; i++) {\n      if (!positions.includes(i)) return i;\n    }\n    return start;\n  }\n\n  public replace(\n    maskString: string,\n    value: string,\n    start: number,\n    end: number\n  ) {\n    let masked = maskString ?? '';\n    const chars = Array.from(replaceIMENumbers(value));\n    const positions = this.literalPositions;\n    const final = Math.min(end, masked.length);\n    let cursor = start;\n\n    for (let i = start; i < final || (chars.length && i < masked.length); i++) {\n      if (positions.includes(i)) {\n        if (chars[0] === masked[i]) {\n          cursor = i + 1;\n          chars.shift();\n        }\n        continue;\n      }\n\n      if (\n        chars[0] &&\n        !this.validate(chars[0], this._escapedMask[i]) &&\n        !this.isPromptChar(chars[0])\n      ) {\n        break;\n      }\n\n      let char = this.prompt;\n      if (chars.length) {\n        cursor = i + 1;\n        char = chars.shift() as string;\n      }\n      masked = this.replaceCharAt(masked, i, char);\n    }\n\n    return { value: masked, end: cursor };\n  }\n\n  public parse(masked = '') {\n    const positions = this.literalPositions;\n    const result = [];\n    const iter = Array.from(masked).entries();\n\n    for (const [pos, char] of iter) {\n      !positions.includes(pos) && !this.isPromptChar(char)\n        ? result.push(char)\n        : result.push('');\n    }\n\n    return result.join('');\n  }\n\n  public isValidString(input = '') {\n    const required = this.getRequiredNonLiteralPositions(this._escapedMask);\n\n    if (required.length > this.parse(input).length) {\n      return false;\n    }\n\n    return required.every((pos) => {\n      const char = input.charAt(pos);\n      return (\n        this.validate(char, this._escapedMask.charAt(pos)) &&\n        !this.isPromptChar(char)\n      );\n    });\n  }\n\n  public apply(input = '') {\n    const output = new Array(this._escapedMask.length).fill(this.prompt);\n\n    for (const [pos, char] of this.literals.entries()) {\n      output[pos] = char;\n    }\n\n    if (!input) {\n      return output.join('');\n    }\n\n    const nonLiteralPositions = this.getNonLiteralPositions(this._escapedMask);\n    const values = nonLiteralPositions.map((pos, index) => {\n      const char = input.charAt(index);\n      return !this.validate(char, this._escapedMask.charAt(pos)) &&\n        !this.isPromptChar(char)\n        ? this.prompt\n        : char;\n    });\n\n    if (values.length > nonLiteralPositions.length) {\n      values.splice(nonLiteralPositions.length);\n    }\n\n    for (const [position, char] of values.entries()) {\n      output[nonLiteralPositions[position]] = char;\n    }\n\n    return output.join('');\n  }\n}\n"]}