interface MaskOptions {
    format: string;
    promptCharacter: string;
}
export declare class MaskParser {
    protected options: MaskOptions;
    constructor(options?: MaskOptions);
    protected literals: Map<number, string>;
    protected _escapedMask: string;
    get literalPositions(): number[];
    get escapedMask(): string;
    get mask(): string;
    set mask(value: string);
    get prompt(): string;
    set prompt(value: string);
    protected parseMaskLiterals(): void;
    protected isPromptChar(char: string): boolean;
    protected replaceCharAt(string: string, pos: number, char: string): string;
    protected validate(char: string, maskedChar: string): boolean;
    protected getNonLiteralPositions(mask?: string): number[];
    protected getRequiredNonLiteralPositions(mask: string): number[];
    getPreviousNonLiteralPosition(start: number): number;
    getNextNonLiteralPosition(start: number): number;
    replace(maskString: string, value: string, start: number, end: number): {
        value: string;
        end: number;
    };
    parse(masked?: string): string;
    isValidString(input?: string): boolean;
    apply(input?: string): string;
}
export {};
