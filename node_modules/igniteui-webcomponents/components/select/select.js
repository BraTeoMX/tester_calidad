var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var IgcSelectComponent_1;
import { html } from 'lit';
import { property, query, queryAssignedElements, state, } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { themeSymbol, themes } from '../../theming/theming-decorator.js';
import { addKeybindings, altKey, arrowDown, arrowLeft, arrowRight, arrowUp, endKey, enterKey, escapeKey, homeKey, spaceBar, tabKey, } from '../common/controllers/key-bindings.js';
import { addRootClickHandler } from '../common/controllers/root-click.js';
import { addRootScrollHandler } from '../common/controllers/root-scroll.js';
import { alternateName } from '../common/decorators/alternateName.js';
import { blazorAdditionalDependencies } from '../common/decorators/blazorAdditionalDependencies.js';
import { blazorSuppress } from '../common/decorators/blazorSuppress.js';
import { watch } from '../common/decorators/watch.js';
import { registerComponent } from '../common/definitions/register.js';
import { IgcBaseComboBoxLikeComponent, getActiveItems, getItems, getNextActiveItem, getPreviousActiveItem, setInitialSelectionState, } from '../common/mixins/combo-box.js';
import { EventEmitterMixin } from '../common/mixins/event-emitter.js';
import { FormAssociatedRequiredMixin } from '../common/mixins/form-associated-required.js';
import { findElementFromEventPath, partNameMap } from '../common/util.js';
import { requiredValidator } from '../common/validators.js';
import IgcIconComponent from '../icon/icon.js';
import IgcInputComponent from '../input/input.js';
import IgcPopoverComponent from '../popover/popover.js';
import IgcSelectGroupComponent from './select-group.js';
import IgcSelectHeaderComponent from './select-header.js';
import IgcSelectItemComponent from './select-item.js';
import { styles } from './themes/select.base.css.js';
import { styles as shared } from './themes/shared/select.common.css.js';
import { all } from './themes/themes.js';
let IgcSelectComponent = IgcSelectComponent_1 = class IgcSelectComponent extends FormAssociatedRequiredMixin(EventEmitterMixin(IgcBaseComboBoxLikeComponent)) {
    static register() {
        registerComponent(IgcSelectComponent_1, IgcIconComponent, IgcInputComponent, IgcPopoverComponent, IgcSelectGroupComponent, IgcSelectHeaderComponent, IgcSelectItemComponent);
    }
    get isMaterialTheme() {
        return this[themeSymbol] === 'material';
    }
    get _activeItems() {
        return Array.from(getActiveItems(this, IgcSelectItemComponent.tagName));
    }
    get hasExpandedIcon() {
        return this._expandedIconSlot.length > 0;
    }
    get hasPrefixes() {
        return this.inputPrefix.length > 0;
    }
    get hasSuffixes() {
        return this.inputSuffix.length > 0;
    }
    get hasHelperText() {
        return this.helperText.length > 0;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._updateValue(value);
        const item = this.getItem(this._value);
        item ? this.setSelectedItem(item) : this.clearSelectedItem();
    }
    get items() {
        return Array.from(getItems(this, IgcSelectItemComponent.tagName));
    }
    get groups() {
        return Array.from(getItems(this, IgcSelectGroupComponent.tagName));
    }
    get selectedItem() {
        return this._selectedItem;
    }
    scrollStrategyChanged() {
        this._rootScrollController.update({ resetListeners: true });
    }
    openChange() {
        this._rootClickController.update();
        this._rootScrollController.update();
    }
    constructor() {
        super();
        this._searchTerm = '';
        this._lastKeyTime = 0;
        this._rootClickController = addRootClickHandler(this, {
            hideCallback: () => this._hide(true),
        });
        this._rootScrollController = addRootScrollHandler(this, {
            hideCallback: () => this._hide(true),
        });
        this._selectedItem = null;
        this.validators = [requiredValidator];
        this.outlined = false;
        this.distance = 0;
        this.placement = 'bottom-start';
        this.positionStrategy = 'fixed';
        this.scrollStrategy = 'scroll';
        this.sameWidth = true;
        this.flip = true;
        addKeybindings(this, {
            skip: () => this.disabled,
            bindingDefaults: { preventDefault: true, triggers: ['keydownRepeat'] },
        })
            .set([altKey, arrowDown], this.altArrowDown)
            .set([altKey, arrowUp], this.altArrowUp)
            .set(arrowDown, this.onArrowDown)
            .set(arrowUp, this.onArrowUp)
            .set(arrowLeft, this.onArrowUp)
            .set(arrowRight, this.onArrowDown)
            .set(tabKey, this.onTabKey, { preventDefault: false })
            .set(escapeKey, this.onEscapeKey)
            .set(homeKey, this.onHomeKey)
            .set(endKey, this.onEndKey)
            .set(spaceBar, this.onSpaceBarKey)
            .set(enterKey, this.onEnterKey);
        this.addEventListener('keydown', this.handleSearch);
        this.addEventListener('focusin', this.handleFocusIn);
        this.addEventListener('focusout', this.handleFocusOut);
    }
    async firstUpdated() {
        await this.updateComplete;
        const selected = setInitialSelectionState(this.items);
        if (this.value && !selected) {
            this._selectItem(this.getItem(this.value), false);
        }
        if (selected && selected.value !== this.value) {
            this._defaultValue = selected.value;
            this._selectItem(selected, false);
        }
        if (this.autofocus) {
            this.focus();
        }
        this.updateValidity();
    }
    handleFocusIn({ relatedTarget }) {
        this._dirty = true;
        if (this.contains(relatedTarget) || this.open) {
            return;
        }
        this.emitEvent('igcFocus');
    }
    handleFocusOut({ relatedTarget }) {
        if (this.contains(relatedTarget)) {
            return;
        }
        this.checkValidity();
        this.emitEvent('igcBlur');
    }
    handleClick(event) {
        const item = findElementFromEventPath(IgcSelectItemComponent.tagName, event);
        if (item && this._activeItems.includes(item)) {
            this._selectItem(item);
        }
    }
    handleChange(item) {
        return this.emitEvent('igcChange', { detail: item });
    }
    handleSearch(event) {
        if (!/^.$/u.test(event.key)) {
            return;
        }
        event.preventDefault();
        const now = Date.now();
        if (now - this._lastKeyTime > 500) {
            this._searchTerm = '';
        }
        this._lastKeyTime = now;
        this._searchTerm += event.key.toLocaleLowerCase();
        const item = this._activeItems.find((item) => item.textContent?.trim().toLocaleLowerCase().startsWith(this._searchTerm));
        if (item) {
            this.open ? this.activateItem(item) : this._selectItem(item);
            this._activeItem.focus();
        }
    }
    handleAnchorClick() {
        super.handleAnchorClick();
        this.focusItemOnOpen();
    }
    onEnterKey() {
        this.open && this._activeItem
            ? this._selectItem(this._activeItem)
            : this.handleAnchorClick();
    }
    onSpaceBarKey() {
        if (!this.open) {
            this.handleAnchorClick();
        }
    }
    onArrowDown() {
        const item = getNextActiveItem(this.items, this._activeItem);
        this.open ? this._navigateToActiveItem(item) : this._selectItem(item);
    }
    onArrowUp() {
        const item = getPreviousActiveItem(this.items, this._activeItem);
        this.open ? this._navigateToActiveItem(item) : this._selectItem(item);
    }
    altArrowDown() {
        if (!this.open) {
            this._show(true);
            this.focusItemOnOpen();
        }
    }
    async altArrowUp() {
        if (this.open && (await this._hide(true))) {
            this.input.focus();
        }
    }
    async onEscapeKey() {
        if (await this._hide(true)) {
            this.input.focus();
        }
    }
    onTabKey(event) {
        if (this.open) {
            event.preventDefault();
            this._selectItem(this._activeItem);
            this._hide(true);
        }
    }
    onHomeKey() {
        const item = this._activeItems.at(0);
        this.open ? this._navigateToActiveItem(item) : this._selectItem(item);
    }
    onEndKey() {
        const item = this._activeItems.at(-1);
        this.open ? this._navigateToActiveItem(item) : this._selectItem(item);
    }
    inputSlotChanged() {
        this.requestUpdate();
    }
    activateItem(item) {
        if (this._activeItem) {
            this._activeItem.active = false;
        }
        this._activeItem = item;
        this._activeItem.active = true;
    }
    setSelectedItem(item) {
        if (this._selectedItem) {
            this._selectedItem.selected = false;
        }
        this._selectedItem = item;
        this._selectedItem.selected = true;
        return this._selectedItem;
    }
    _selectItem(item, emit = true) {
        if (!item) {
            this.clearSelectedItem();
            this._updateValue();
            return null;
        }
        const items = this.items;
        const [previous, current] = [
            items.indexOf(this._selectedItem),
            items.indexOf(item),
        ];
        if (previous === current) {
            return this._selectedItem;
        }
        const newItem = this.setSelectedItem(item);
        this.activateItem(newItem);
        this._updateValue(newItem.value);
        if (emit)
            this.handleChange(newItem);
        if (emit && this.open)
            this.input.focus();
        if (emit && !this.keepOpenOnSelect)
            this._hide(true);
        return this._selectedItem;
    }
    _navigateToActiveItem(item) {
        if (item) {
            this.activateItem(item);
            this._activeItem.focus({ preventScroll: true });
            item.scrollIntoView({ behavior: 'auto', block: 'nearest' });
        }
    }
    _updateValue(value) {
        this._value = value;
        this.setFormValue(this._value ? this._value : null);
        this.updateValidity();
        this.setInvalidState();
    }
    clearSelectedItem() {
        if (this._selectedItem) {
            this._selectedItem.selected = false;
        }
        this._selectedItem = null;
    }
    async focusItemOnOpen() {
        await this.updateComplete;
        (this._selectedItem || this._activeItem)?.focus();
    }
    getItem(value) {
        return this.items.find((item) => item.value === value);
    }
    _stopPropagation(e) {
        e.stopPropagation();
    }
    focus(options) {
        this.input.focus(options);
    }
    blur() {
        this.input.blur();
        super.blur();
    }
    reportValidity() {
        const valid = super.reportValidity();
        if (!valid)
            this.input.focus();
        return valid;
    }
    navigateTo(value) {
        const item = typeof value === 'string' ? this.getItem(value) : this.items[value];
        if (item) {
            this._navigateToActiveItem(item);
        }
        return item ?? null;
    }
    select(value) {
        const item = typeof value === 'string' ? this.getItem(value) : this.items[value];
        return item ? this._selectItem(item, false) : null;
    }
    clearSelection() {
        this._updateValue();
        this.clearSelectedItem();
    }
    renderInputSlots() {
        const prefixName = this.hasPrefixes ? 'prefix' : '';
        const suffixName = this.hasSuffixes ? 'suffix' : '';
        return html `
      <span slot=${prefixName}>
        <slot name="prefix" @slotchange=${this.inputSlotChanged}></slot>
      </span>

      <span slot=${suffixName}>
        <slot name="suffix" @slotchange=${this.inputSlotChanged}></slot>
      </span>
    `;
    }
    renderToggleIcon() {
        const parts = partNameMap({ 'toggle-icon': true, filled: this.value });
        const iconHidden = this.open && this.hasExpandedIcon;
        const iconExpandedHidden = !this.hasExpandedIcon || !this.open;
        const openIcon = this.isMaterialTheme
            ? 'keyboard_arrow_up'
            : 'arrow_drop_up';
        const closeIcon = this.isMaterialTheme
            ? 'keyboard_arrow_down'
            : 'arrow_drop_down';
        return html `
      <span slot="suffix" part=${parts} aria-hidden="true">
        <slot
          name="toggle-icon"
          ?hidden=${iconHidden}
          @slotchange=${this.inputSlotChanged}
        >
          <igc-icon
            name=${this.open ? openIcon : closeIcon}
            collection="internal"
          ></igc-icon>
        </slot>
        <slot
          name="toggle-icon-expanded"
          ?hidden=${iconExpandedHidden}
          @slotchange=${this.inputSlotChanged}
        ></slot>
      </span>
    `;
    }
    renderHelperText() {
        return html `
      <div
        id="helper-text"
        part="helper-text"
        slot="anchor"
        ?hidden=${!this.hasHelperText}
      >
        <slot name="helper-text" @slotchange=${this.inputSlotChanged}></slot>
      </div>
    `;
    }
    renderInputAnchor() {
        const value = this.selectedItem?.textContent?.trim();
        return html `
      <igc-input
        id="input"
        slot="anchor"
        role="combobox"
        readonly
        aria-controls="dropdown"
        aria-describedby="helper-text"
        aria-expanded=${this.open ? 'true' : 'false'}
        exportparts="container: input, input: native-input, label, prefix, suffix"
        tabIndex=${this.disabled ? -1 : 0}
        value=${ifDefined(value)}
        placeholder=${ifDefined(this.placeholder)}
        label=${ifDefined(this.label)}
        .disabled=${this.disabled}
        .required=${this.required}
        .invalid=${this.invalid}
        .outlined=${this.outlined}
        @click=${this.handleAnchorClick}
        @igcFocus=${this._stopPropagation}
        @igcBlur=${this._stopPropagation}
      >
        ${this.renderInputSlots()} ${this.renderToggleIcon()}
      </igc-input>

      ${this.renderHelperText()}
    `;
    }
    renderDropdown() {
        return html `<div part="base" .inert=${!this.open}>
      <div
        id="dropdown"
        role="listbox"
        part="list"
        aria-labelledby="input"
        @click=${this.handleClick}
      >
        <slot name="header"></slot>
        <slot></slot>
        <slot name="footer"></slot>
      </div>
    </div>`;
    }
    render() {
        return html `<igc-popover
      ?open=${this.open}
      flip
      shift
      same-width
      .offset=${this.distance}
      .placement=${this.placement}
      >${this.renderInputAnchor()} ${this.renderDropdown()}
    </igc-popover>`;
    }
};
IgcSelectComponent.tagName = 'igc-select';
IgcSelectComponent.styles = [styles, shared];
__decorate([
    state()
], IgcSelectComponent.prototype, "_selectedItem", void 0);
__decorate([
    state()
], IgcSelectComponent.prototype, "_activeItem", void 0);
__decorate([
    query(IgcInputComponent.tagName, true)
], IgcSelectComponent.prototype, "input", void 0);
__decorate([
    queryAssignedElements({ slot: 'helper-text' })
], IgcSelectComponent.prototype, "helperText", void 0);
__decorate([
    queryAssignedElements({ slot: 'suffix' })
], IgcSelectComponent.prototype, "inputSuffix", void 0);
__decorate([
    queryAssignedElements({ slot: 'prefix' })
], IgcSelectComponent.prototype, "inputPrefix", void 0);
__decorate([
    queryAssignedElements({ slot: 'toggle-icon-expanded' })
], IgcSelectComponent.prototype, "_expandedIconSlot", void 0);
__decorate([
    property()
], IgcSelectComponent.prototype, "value", null);
__decorate([
    property({ reflect: true, type: Boolean })
], IgcSelectComponent.prototype, "outlined", void 0);
__decorate([
    property({ type: Boolean })
], IgcSelectComponent.prototype, "autofocus", void 0);
__decorate([
    property({ type: Number })
], IgcSelectComponent.prototype, "distance", void 0);
__decorate([
    property()
], IgcSelectComponent.prototype, "label", void 0);
__decorate([
    property()
], IgcSelectComponent.prototype, "placeholder", void 0);
__decorate([
    property()
], IgcSelectComponent.prototype, "placement", void 0);
__decorate([
    property({ attribute: 'scroll-strategy' })
], IgcSelectComponent.prototype, "scrollStrategy", void 0);
__decorate([
    property({ type: Boolean, attribute: 'same-width' })
], IgcSelectComponent.prototype, "sameWidth", void 0);
__decorate([
    property({ type: Boolean })
], IgcSelectComponent.prototype, "flip", void 0);
__decorate([
    watch('scrollStrategy', { waitUntilFirstUpdate: true })
], IgcSelectComponent.prototype, "scrollStrategyChanged", null);
__decorate([
    watch('open', { waitUntilFirstUpdate: true })
], IgcSelectComponent.prototype, "openChange", null);
__decorate([
    alternateName('focusComponent')
], IgcSelectComponent.prototype, "focus", null);
__decorate([
    alternateName('blurComponent')
], IgcSelectComponent.prototype, "blur", null);
__decorate([
    blazorSuppress()
], IgcSelectComponent.prototype, "navigateTo", null);
__decorate([
    blazorSuppress()
], IgcSelectComponent.prototype, "select", null);
IgcSelectComponent = IgcSelectComponent_1 = __decorate([
    themes(all, true),
    blazorAdditionalDependencies('IgcIconComponent, IgcInputComponent, IgcSelectGroupComponent, IgcSelectHeaderComponent, IgcSelectItemComponent')
], IgcSelectComponent);
export default IgcSelectComponent;
//# sourceMappingURL=select.js.map