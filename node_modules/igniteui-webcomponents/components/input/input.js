var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html } from 'lit';
import { property } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { live } from 'lit/directives/live.js';
import { watch } from '../common/decorators/watch.js';
import { registerComponent } from '../common/definitions/register.js';
import { partNameMap } from '../common/util.js';
import { emailValidator, maxLengthValidator, maxValidator, minLengthValidator, minValidator, patternValidator, requiredNumberValidator, requiredValidator, stepValidator, urlValidator, } from '../common/validators.js';
import { IgcInputBaseComponent } from './input-base.js';
class IgcInputComponent extends IgcInputBaseComponent {
    constructor() {
        super(...arguments);
        this.validators = [
            {
                ...requiredValidator,
                isValid: () => this.isStringType
                    ? requiredValidator.isValid(this)
                    : requiredNumberValidator.isValid(this),
            },
            {
                ...minLengthValidator,
                isValid: () => this.isStringType ? minLengthValidator.isValid(this) : true,
            },
            {
                ...maxLengthValidator,
                isValid: () => this.isStringType ? maxLengthValidator.isValid(this) : true,
            },
            {
                ...minValidator,
                isValid: () => (this.isStringType ? true : minValidator.isValid(this)),
            },
            {
                ...maxValidator,
                isValid: () => (this.isStringType ? true : maxValidator.isValid(this)),
            },
            {
                ...stepValidator,
                isValid: () => (this.isStringType ? true : stepValidator.isValid(this)),
            },
            {
                ...patternValidator,
                isValid: () => this.isStringType ? patternValidator.isValid(this) : true,
            },
            {
                key: 'typeMismatch',
                isValid: () => {
                    switch (this.type) {
                        case 'email':
                            return emailValidator.isValid(this);
                        case 'url':
                            return urlValidator.isValid(this);
                        default:
                            return true;
                    }
                },
                message: () => (this.type === 'email'
                    ? emailValidator.message
                    : urlValidator.message),
            },
        ];
        this._value = '';
        this.type = 'text';
        this.validateOnly = false;
        this.tabIndex = 0;
    }
    static register() {
        registerComponent(IgcInputComponent);
    }
    get isStringType() {
        return this.type !== 'number';
    }
    set value(value) {
        this._value = value ?? '';
        this.setFormValue(value ? value : null);
        this.updateValidity();
        this.setInvalidState();
    }
    get value() {
        return this._value;
    }
    set inputmode(value) {
        this.inputMode = value;
    }
    get inputmode() {
        return this.inputMode;
    }
    set minlength(value) {
        this.minLength = value;
    }
    get minlength() {
        return this.minLength;
    }
    set maxlength(value) {
        this.maxLength = value;
    }
    get maxlength() {
        return this.maxLength;
    }
    constraintsChanged() {
        this.updateValidity();
    }
    connectedCallback() {
        super.connectedCallback();
        this.setFormValue(this._value ? this._value : null);
        this.updateValidity();
    }
    setRangeText(replacement, start, end, selectMode = 'preserve') {
        super.setRangeText(replacement, start, end, selectMode);
        this.value = this.input.value;
    }
    select() {
        return this.input.select();
    }
    stepUp(n) {
        this.input.stepUp(n);
        this.value = this.input.value;
    }
    stepDown(n) {
        this.input.stepDown(n);
        this.value = this.input.value;
    }
    handleInput() {
        this.value = this.input.value;
        this.emitEvent('igcInput', { detail: this.value });
    }
    handleChange() {
        this.value = this.input.value;
        this.emitEvent('igcChange', { detail: this.value });
    }
    handleFocus() {
        this._dirty = true;
        super.handleFocus();
    }
    handleBlur() {
        this.checkValidity();
        super.handleBlur();
    }
    renderInput() {
        return html `
      <input
        id=${this.inputId}
        part=${partNameMap(this.resolvePartNames('input'))}
        name=${ifDefined(this.name)}
        type=${ifDefined(this.type)}
        pattern=${ifDefined(this.pattern)}
        placeholder=${ifDefined(this.placeholder)}
        .value=${live(this.value)}
        ?readonly=${this.readOnly}
        ?disabled=${this.disabled}
        ?required=${this.required}
        ?autofocus=${this.autofocus}
        tabindex=${this.tabIndex}
        autocomplete=${ifDefined(this.autocomplete)}
        inputmode=${ifDefined(this.inputMode)}
        min=${ifDefined(this.validateOnly ? undefined : this.min)}
        max=${ifDefined(this.validateOnly ? undefined : this.max)}
        minlength=${ifDefined(this.minLength)}
        maxlength=${ifDefined(this.validateOnly ? undefined : this.maxLength)}
        step=${ifDefined(this.step)}
        aria-invalid=${this.invalid ? 'true' : 'false'}
        @change=${this.handleChange}
        @input=${this.handleInput}
        @focus=${this.handleFocus}
        @blur=${this.handleBlur}
      />
    `;
    }
}
IgcInputComponent.tagName = 'igc-input';
export default IgcInputComponent;
__decorate([
    property()
], IgcInputComponent.prototype, "value", null);
__decorate([
    property({ reflect: true })
], IgcInputComponent.prototype, "type", void 0);
__decorate([
    property({ attribute: false })
], IgcInputComponent.prototype, "inputmode", null);
__decorate([
    property({ attribute: 'inputmode' })
], IgcInputComponent.prototype, "inputMode", void 0);
__decorate([
    property()
], IgcInputComponent.prototype, "pattern", void 0);
__decorate([
    property({ type: Number, attribute: 'minlength' })
], IgcInputComponent.prototype, "minLength", void 0);
__decorate([
    property({ attribute: false })
], IgcInputComponent.prototype, "minlength", null);
__decorate([
    property({ type: Number, attribute: 'maxlength' })
], IgcInputComponent.prototype, "maxLength", void 0);
__decorate([
    property({ attribute: false })
], IgcInputComponent.prototype, "maxlength", null);
__decorate([
    property()
], IgcInputComponent.prototype, "min", void 0);
__decorate([
    property()
], IgcInputComponent.prototype, "max", void 0);
__decorate([
    property({ type: Number })
], IgcInputComponent.prototype, "step", void 0);
__decorate([
    property({ type: Boolean })
], IgcInputComponent.prototype, "autofocus", void 0);
__decorate([
    property()
], IgcInputComponent.prototype, "autocomplete", void 0);
__decorate([
    property({ type: Boolean, reflect: true, attribute: 'validate-only' })
], IgcInputComponent.prototype, "validateOnly", void 0);
__decorate([
    property({ type: Number })
], IgcInputComponent.prototype, "tabIndex", void 0);
__decorate([
    watch('min', { waitUntilFirstUpdate: true }),
    watch('max', { waitUntilFirstUpdate: true }),
    watch('minLength', { waitUntilFirstUpdate: true }),
    watch('maxLength', { waitUntilFirstUpdate: true }),
    watch('pattern', { waitUntilFirstUpdate: true }),
    watch('step', { waitUntilFirstUpdate: true })
], IgcInputComponent.prototype, "constraintsChanged", null);
//# sourceMappingURL=input.js.map