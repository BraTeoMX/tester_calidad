var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var IgcTextareaComponent_1;
import { LitElement, html, nothing } from 'lit';
import { property, query, queryAssignedElements, queryAssignedNodes, } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { live } from 'lit/directives/live.js';
import { styleMap } from 'lit/directives/style-map.js';
import { themeSymbol, themes } from '../../theming/theming-decorator.js';
import { watch } from '../common/decorators/watch.js';
import { registerComponent } from '../common/definitions/register.js';
import { EventEmitterMixin } from '../common/mixins/event-emitter.js';
import { FormAssociatedRequiredMixin } from '../common/mixins/form-associated-required.js';
import { asNumber, createCounter, partNameMap } from '../common/util.js';
import { maxLengthValidator, minLengthValidator, requiredValidator, } from '../common/validators.js';
import { styles as shared } from './themes/shared/textarea.common.css.js';
import { styles } from './themes/textarea.base.css.js';
import { all } from './themes/themes.js';
let IgcTextareaComponent = IgcTextareaComponent_1 = class IgcTextareaComponent extends FormAssociatedRequiredMixin(EventEmitterMixin(LitElement)) {
    static register() {
        registerComponent(IgcTextareaComponent_1);
    }
    get resizeStyles() {
        return {
            resize: this.resize === 'auto' ? 'none' : this.resize,
        };
    }
    set value(value) {
        this._value = value ?? '';
        this.setFormValue(this._value ? this._value : null);
        this.updateValidity();
        this.setInvalidState();
    }
    get value() {
        return this._value;
    }
    constructor() {
        super();
        this.validators = [
            requiredValidator,
            minLengthValidator,
            maxLengthValidator,
        ];
        this.inputId = `textarea-${IgcTextareaComponent_1.increment()}`;
        this._value = '';
        this.outlined = false;
        this.readOnly = false;
        this.resize = 'vertical';
        this.rows = 2;
        this.spellcheck = true;
        this.wrap = 'soft';
        this.validateOnly = false;
        this.addEventListener('focus', () => {
            this._dirty = true;
            this.emitEvent('igcFocus');
        });
        this.addEventListener('blur', () => {
            this.updateValidity();
            this.setInvalidState();
            this.emitEvent('igcBlur');
        });
    }
    async connectedCallback() {
        super.connectedCallback();
        this.updateValidity();
        await this.updateComplete;
        this.setAreaHeight();
        this.observer = new ResizeObserver(() => this.setAreaHeight());
        this.observer.observe(this.input);
    }
    disconnectedCallback() {
        this.observer.disconnect();
        super.disconnectedCallback();
    }
    select() {
        this.input.select();
    }
    setSelectionRange(start, end, direction = 'none') {
        this.input.setSelectionRange(start, end, direction);
    }
    setRangeText(replacement, start, end, selectMode = 'preserve') {
        this.input.setRangeText(replacement, start, end, selectMode);
        this.value = this.input.value;
    }
    scrollTo(x, y) {
        x !== undefined && y !== undefined
            ? this.input.scrollTo(x, y)
            : this.input.scrollTo(x);
    }
    resolvePartNames(base) {
        return {
            [base]: true,
            prefixed: this.prefixes.length > 0,
            suffixed: this.suffixes.length > 0,
            filled: !!this.value,
        };
    }
    async firstUpdated() {
        await this.updateComplete;
        this._defaultValue = this.value;
    }
    async valueChanged() {
        await this.updateComplete;
        this.setAreaHeight();
    }
    setAreaHeight() {
        if (this.resize === 'auto') {
            this.input.style.height = 'auto';
            this.input.style.height = `${this.setAutoHeight()}px`;
        }
        else {
            Object.assign(this.input.style, { height: undefined });
        }
    }
    setAutoHeight() {
        const computed = getComputedStyle(this.input);
        const [top, bottom] = [
            asNumber(computed.getPropertyValue('border-top-width')),
            asNumber(computed.getPropertyValue('border-bottom-width')),
        ];
        return this.input.scrollHeight + top + bottom;
    }
    handleInput() {
        this.value = this.input.value;
        this.emitEvent('igcInput', { detail: this.value });
    }
    handleChange() {
        this.value = this.input.value;
        this.emitEvent('igcChange', { detail: this.value });
    }
    valueSlotChange() {
        const value = [];
        for (const node of this.projected) {
            const text = node.textContent?.trim();
            if (text) {
                value.push(text);
            }
        }
        if (value.length) {
            this.value = value.join('\r\n');
        }
    }
    slotChange() {
        this.requestUpdate();
    }
    renderValueSlot() {
        return html `<slot
      style="display: none"
      @slotchange=${this.valueSlotChange}
    ></slot>`;
    }
    renderHelperText() {
        return html `
      <div part="helper-text" .hidden=${this.helperText.length < 1}>
        <slot name="helper-text" @slotchange=${this.slotChange}></slot>
      </div>
    `;
    }
    renderPrefix() {
        return html `<div part="prefix" .hidden=${this.prefixes.length < 1}>
      <slot name="prefix" @slotchange=${this.slotChange}></slot>
    </div>`;
    }
    renderSuffix() {
        return html `<div part="suffix" .hidden=${this.suffixes.length < 1}>
      <slot name="suffix" @slotchange=${this.slotChange}></slot>
    </div>`;
    }
    renderLabel() {
        return this.label
            ? html `<label part="label" for=${this.id || this.inputId}
          >${this.label}</label
        >`
            : nothing;
    }
    renderStandard() {
        return html `
      ${this.renderLabel()}
      <div part=${partNameMap(this.resolvePartNames('container'))}>
        ${this.renderPrefix()} ${this.renderInput()} ${this.renderSuffix()}
      </div>
      ${this.renderHelperText()}
    `;
    }
    renderMaterial() {
        return html `
      <div
        part=${partNameMap({
            ...this.resolvePartNames('container'),
            labelled: this.label,
        })}
      >
        <div part="start">${this.renderPrefix()}</div>
        <div part="notch">${this.renderLabel()}</div>
        ${this.renderInput()}
        <div part="filler"></div>
        <div part="end">${this.renderSuffix()}</div>
      </div>
      ${this.renderHelperText()}
    `;
    }
    renderInput() {
        return html `${this.renderValueSlot()}
      <textarea
        id=${this.id || this.inputId}
        part="input"
        style=${styleMap(this.resizeStyles)}
        @input=${this.handleInput}
        @change=${this.handleChange}
        placeholder=${ifDefined(this.placeholder)}
        .rows=${this.rows}
        .value=${live(this.value)}
        .wrap=${this.wrap}
        autocomplete=${ifDefined(this.autocomplete)}
        autocapitalize=${ifDefined(this.autocapitalize)}
        inputmode=${ifDefined(this.inputMode)}
        spellcheck=${ifDefined(this.spellcheck)}
        minlength=${ifDefined(this.minLength)}
        maxlength=${ifDefined(this.validateOnly ? undefined : this.maxLength)}
        ?disabled=${this.disabled}
        ?required=${this.required}
        ?readonly=${this.readOnly}
        aria-invalid=${this.invalid ? 'true' : 'false'}
      ></textarea>`;
    }
    render() {
        const isMaterial = this[themeSymbol] === 'material';
        return isMaterial ? this.renderMaterial() : this.renderStandard();
    }
};
IgcTextareaComponent.tagName = 'igc-textarea';
IgcTextareaComponent.styles = [styles, shared];
IgcTextareaComponent.increment = createCounter();
IgcTextareaComponent.shadowRootOptions = {
    ...LitElement.shadowRootOptions,
    delegatesFocus: true,
};
__decorate([
    queryAssignedNodes({ flatten: true })
], IgcTextareaComponent.prototype, "projected", void 0);
__decorate([
    queryAssignedElements({ slot: 'prefix' })
], IgcTextareaComponent.prototype, "prefixes", void 0);
__decorate([
    queryAssignedElements({ slot: 'suffix' })
], IgcTextareaComponent.prototype, "suffixes", void 0);
__decorate([
    queryAssignedElements({ slot: 'helper-text' })
], IgcTextareaComponent.prototype, "helperText", void 0);
__decorate([
    query('textarea', true)
], IgcTextareaComponent.prototype, "input", void 0);
__decorate([
    property()
], IgcTextareaComponent.prototype, "autocomplete", void 0);
__decorate([
    property()
], IgcTextareaComponent.prototype, "autocapitalize", void 0);
__decorate([
    property({ attribute: 'inputmode' })
], IgcTextareaComponent.prototype, "inputMode", void 0);
__decorate([
    property()
], IgcTextareaComponent.prototype, "label", void 0);
__decorate([
    property({ type: Number, attribute: 'maxlength' })
], IgcTextareaComponent.prototype, "maxLength", void 0);
__decorate([
    property({ type: Number, attribute: 'minlength' })
], IgcTextareaComponent.prototype, "minLength", void 0);
__decorate([
    property({ reflect: true, type: Boolean })
], IgcTextareaComponent.prototype, "outlined", void 0);
__decorate([
    property()
], IgcTextareaComponent.prototype, "placeholder", void 0);
__decorate([
    property({ type: Boolean, reflect: true, attribute: 'readonly' })
], IgcTextareaComponent.prototype, "readOnly", void 0);
__decorate([
    property()
], IgcTextareaComponent.prototype, "resize", void 0);
__decorate([
    property({ type: Number })
], IgcTextareaComponent.prototype, "rows", void 0);
__decorate([
    property()
], IgcTextareaComponent.prototype, "value", null);
__decorate([
    property({
        type: Boolean,
        converter: {
            fromAttribute: (value) => !(!value || value === 'false'),
            toAttribute: (value) => (value ? 'true' : 'false'),
        },
    })
], IgcTextareaComponent.prototype, "spellcheck", void 0);
__decorate([
    property()
], IgcTextareaComponent.prototype, "wrap", void 0);
__decorate([
    property({ type: Boolean, reflect: true, attribute: 'validate-only' })
], IgcTextareaComponent.prototype, "validateOnly", void 0);
__decorate([
    watch('value')
], IgcTextareaComponent.prototype, "valueChanged", null);
__decorate([
    watch('rows', { waitUntilFirstUpdate: true }),
    watch('resize', { waitUntilFirstUpdate: true })
], IgcTextareaComponent.prototype, "setAreaHeight", null);
IgcTextareaComponent = IgcTextareaComponent_1 = __decorate([
    themes(all, true)
], IgcTextareaComponent);
export default IgcTextareaComponent;
//# sourceMappingURL=textarea.js.map