var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var IgcDaysViewComponent_1;
import { html } from 'lit';
import { property, query } from 'lit/decorators.js';
import { themes } from '../../../theming/theming-decorator.js';
import { blazorIndirectRender } from '../../common/decorators/blazorIndirectRender.js';
import { blazorSuppressComponent } from '../../common/decorators/blazorSuppressComponent.js';
import { watch } from '../../common/decorators/watch.js';
import { registerComponent } from '../../common/definitions/register.js';
import { IgcCalendarResourceStringEN, } from '../../common/i18n/calendar.resources.js';
import { EventEmitterMixin } from '../../common/mixins/event-emitter.js';
import { partNameMap } from '../../common/util.js';
import { IgcCalendarBaseComponent, } from '../common/calendar-base.js';
import { DateRangeType, TimeDeltaInterval, isDateInRanges, } from '../common/calendar.model.js';
import { areEqualDates, getDateOnly, isEqual } from '../common/utils.js';
import { styles } from '../themes/days-view.base.css.js';
import { all } from '../themes/days.js';
let IgcDaysViewComponent = IgcDaysViewComponent_1 = class IgcDaysViewComponent extends EventEmitterMixin(IgcCalendarBaseComponent) {
    static register() {
        registerComponent(IgcDaysViewComponent_1);
    }
    formattersChange() {
        this.initFormatters();
    }
    datesChange() {
        this.dates = this.getCalendarMonth();
    }
    constructor() {
        super();
        this.hideLeadingDays = false;
        this.hideTrailingDays = false;
        this.active = false;
        this.weekDayFormat = 'narrow';
        this.resourceStrings = IgcCalendarResourceStringEN;
        this.setAttribute('role', 'grid');
        this.initFormatters();
    }
    focusActiveDate() {
        this.activeDay.focus();
    }
    initFormatters() {
        this.formatterWeekday = new Intl.DateTimeFormat(this.locale, {
            weekday: this.weekDayFormat,
        });
        this.labelFormatter = new Intl.DateTimeFormat(this.locale, {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric',
        });
    }
    generateWeekHeader() {
        const dayNames = [];
        const rv = this.calendarModel.monthdatescalendar(this.activeDate.getFullYear(), this.activeDate.getMonth())[0];
        for (const day of rv) {
            dayNames.push({
                label: this.formatterWeekday.format(day.date),
                ariaLabel: day.date.toLocaleString(this.locale, { weekday: 'long' }),
            });
        }
        return dayNames;
    }
    getCalendarMonth() {
        return this.calendarModel.monthdatescalendar(this.activeDate.getFullYear(), this.activeDate.getMonth(), true);
    }
    titleCase(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }
    getWeekNumber(date) {
        return this.calendarModel.getWeekNumber(date);
    }
    formattedDate(value) {
        return `${value.getDate()}`;
    }
    get isSingleSelection() {
        return this.selection !== 'range';
    }
    isLastInRange(date) {
        if (this.isSingleSelection || !this.values || this.values.length === 0) {
            return false;
        }
        const dates = this.values;
        let lastDate = dates[dates.length - 1];
        if (this.rangePreviewDate) {
            if (this.rangePreviewDate > lastDate) {
                lastDate = this.rangePreviewDate;
            }
        }
        return isEqual(lastDate, date.date);
    }
    isFirstInRange(date) {
        if (this.isSingleSelection || !this.values || this.values.length === 0) {
            return false;
        }
        const dates = this.values;
        let firstDate = dates[0];
        if (this.rangePreviewDate) {
            if (this.rangePreviewDate < firstDate) {
                firstDate = this.rangePreviewDate;
            }
        }
        return isEqual(firstDate, date.date);
    }
    isDisabled(date) {
        if (!this.disabledDates) {
            return false;
        }
        return isDateInRanges(date, this.disabledDates);
    }
    isWithinRange(date, min, max) {
        return isDateInRanges(date, [
            {
                type: DateRangeType.Between,
                dateRange: [min, max],
            },
        ]);
    }
    isRangeDate(date) {
        if (this.selection !== 'range' ||
            !this.values ||
            this.values.length === 0) {
            return false;
        }
        const dates = this.values;
        const min = dates[0];
        let max;
        if (dates.length === 1) {
            if (!this.rangePreviewDate) {
                return false;
            }
            max = this.rangePreviewDate;
        }
        else {
            max = dates[dates.length - 1];
        }
        return isDateInRanges(date, [
            {
                type: DateRangeType.Between,
                dateRange: [min, max],
            },
        ]);
    }
    isRangePreview(date) {
        if (this.selection === 'range' &&
            this.values &&
            this.values.length > 0 &&
            this.rangePreviewDate) {
            return isDateInRanges(date, [
                {
                    type: DateRangeType.Between,
                    dateRange: [this.values[0], this.rangePreviewDate],
                },
            ]);
        }
        return false;
    }
    isSelected(date) {
        if (this.isDisabled(date.date)) {
            return false;
        }
        if (this.selection === 'single') {
            if (!this.value) {
                return false;
            }
            return getDateOnly(this.value).getTime() === date.date.getTime();
        }
        if (!this.values || this.values.length === 0) {
            return false;
        }
        if (this.selection === 'range' && this.values.length === 1) {
            return getDateOnly(this.values[0]).getTime() === date.date.getTime();
        }
        if (this.selection === 'multiple') {
            const start = getDateOnly(this.values[0]);
            const end = getDateOnly(this.values[this.values.length - 1]);
            if (this.isWithinRange(date.date, start, end)) {
                const currentDate = this.values.find((element) => element.getTime() === date.date.getTime());
                return !!currentDate;
            }
            return false;
        }
        return this.isWithinRange(date.date, this.values[0], this.values[this.values.length - 1]);
    }
    isToday(day) {
        const today = new Date(Date.now());
        const date = day.date;
        return (date.getFullYear() === today.getFullYear() &&
            date.getMonth() === today.getMonth() &&
            date.getDate() === today.getDate());
    }
    isWeekend(date) {
        const day = date.date.getDay();
        return day === 0 || day === 6;
    }
    isSpecial(day) {
        if (this.specialDates === null) {
            return false;
        }
        return isDateInRanges(day.date, this.specialDates);
    }
    dateClicked(event, day) {
        event.stopPropagation();
        this.selectDay(day);
        this.changeActiveDate(day);
    }
    selectDay(day) {
        if (this.rangePreviewDate) {
            this.setRangePreviewDate(undefined);
        }
        const result = this.selectDate(day.date);
        if (result) {
            this.emitEvent('igcChange', { detail: day.date });
        }
    }
    selectDate(value) {
        if (this.isDisabled(value)) {
            return false;
        }
        switch (this.selection) {
            case 'single':
                if (this.value?.getTime() === value.getTime()) {
                    return false;
                }
                this.selectSingle(value);
                break;
            case 'multiple':
                this.selectMultiple(value);
                break;
            case 'range':
                this.selectRange(value);
                break;
        }
        return true;
    }
    generateDateRange(start, end) {
        const result = [];
        let startDate = getDateOnly(start);
        const endDate = getDateOnly(end);
        while (startDate.getTime() < endDate.getTime()) {
            startDate = this.calendarModel.timedelta(startDate, TimeDeltaInterval.Day, 1);
            result.push(startDate);
        }
        return result;
    }
    selectRange(value) {
        let start;
        let end;
        let selectedDates = (this.values ?? []);
        if (selectedDates.length !== 1) {
            selectedDates = [value];
        }
        else {
            if (selectedDates[0].getTime() === value.getTime()) {
                this.values = [];
                return;
            }
            selectedDates.push(value);
            selectedDates.sort((a, b) => a.valueOf() - b.valueOf());
            start = selectedDates.shift();
            end = selectedDates.pop();
            selectedDates = [start, ...this.generateDateRange(start, end)];
        }
        selectedDates = selectedDates.filter((d) => !this.isDisabled(d));
        this.values = [...selectedDates];
    }
    selectSingle(value) {
        this.value = getDateOnly(value);
    }
    selectMultiple(value) {
        let selectedDates = (this.values ?? []);
        const valueDateOnly = getDateOnly(value);
        const newSelection = [];
        if (selectedDates.every((date) => date.getTime() !== valueDateOnly.getTime())) {
            newSelection.push(valueDateOnly);
        }
        else {
            selectedDates = selectedDates.filter((date) => date.getTime() !== valueDateOnly.getTime());
        }
        if (newSelection.length > 0) {
            selectedDates = selectedDates.concat(newSelection);
        }
        selectedDates = selectedDates.filter((d) => !this.isDisabled(d));
        selectedDates.sort((a, b) => a.valueOf() - b.valueOf());
        this.values = [...selectedDates];
    }
    changeActiveDate(day) {
        this.activeDate = day.date;
        this.emitEvent('igcActiveDateChange', { detail: day });
    }
    dateKeyDown(event, day) {
        if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            this.selectDay(day);
        }
    }
    changeRangePreview(date) {
        if (this.selection === 'range' &&
            this.values &&
            this.values.length === 1 &&
            !isEqual(this.values[0], date)) {
            this.setRangePreviewDate(date);
        }
    }
    clearRangePreview() {
        if (this.rangePreviewDate) {
            this.setRangePreviewDate(undefined);
        }
    }
    setRangePreviewDate(value) {
        this.rangePreviewDate = value;
        this.emitEvent('igcRangePreviewDateChange', { detail: value });
    }
    resolveDayItemPartName(day) {
        const isInactive = day.isNextMonth || day.isPrevMonth;
        const isHidden = (this.hideLeadingDays && day.isPrevMonth) ||
            (this.hideTrailingDays && day.isNextMonth);
        const isDisabled = this.isDisabled(day.date);
        return {
            date: true,
            first: this.isFirstInRange(day),
            last: this.isLastInRange(day),
            selected: !isDisabled && this.isSelected(day),
            inactive: isInactive,
            hidden: isHidden,
            current: this.isToday(day),
            weekend: this.isWeekend(day),
            range: this.selection === 'range' && this.isRangeDate(day.date),
            special: this.isSpecial(day),
            disabled: isHidden || isDisabled,
            single: this.selection !== 'range',
            preview: this.isRangePreview(day.date),
        };
    }
    renderWeekHeaders() {
        return html `<div role="row" part="days-row first">
      ${this.showWeekNumbers
            ? html `<span role="columnheader" part="label week-number first">
            <span part="week-number-inner first"
              >${this.resourceStrings.weekLabel}</span
            >
          </span>`
            : ''}
      ${this.generateWeekHeader().map((weekday) => html `<span
            role="columnheader"
            part="label"
            aria-label=${weekday.ariaLabel}
          >
            <span part="label-inner">${this.titleCase(weekday.label)}</span>
          </span> `)}
    </div>`;
    }
    renderDates() {
        return this.dates.map((week, i) => {
            const last = i === this.dates.length - 1;
            return html `<div role="row" part="days-row">
        ${this.showWeekNumbers
                ? html `<span
              role="rowheader"
              part=${partNameMap({ 'week-number': true, last })}
            >
              <span part=${partNameMap({ 'week-number-inner': true, last })}
                >${this.getWeekNumber(week[0].date)}</span
              >
            </span>`
                : ''}
        ${week.map((day) => this.renderDateItem(day))}
      </div>`;
        });
    }
    dayLabelFormatter(value) {
        if (this.rangePreviewDate &&
            areEqualDates(this.rangePreviewDate, value.date)) {
            return this.labelFormatter.formatRange(this.values.at(0), this.rangePreviewDate);
        }
        if (this.isFirstInRange(value) || this.isLastInRange(value)) {
            return this.labelFormatter.formatRange(this.values.at(0), this.values.at(-1));
        }
        return this.labelFormatter.format(value.date);
    }
    renderDateItem(day) {
        const datePartName = partNameMap(this.resolveDayItemPartName(day));
        const dateInnerPartName = datePartName.replace('date', 'date-inner');
        return html `<span part=${datePartName}>
      <span
        part=${dateInnerPartName}
        role="gridcell"
        aria-label=${this.dayLabelFormatter(day)}
        aria-selected=${this.isSelected(day)}
        aria-disabled=${this.isDisabled(day.date)}
        tabindex=${this.active && areEqualDates(this.activeDate, day.date)
            ? 0
            : -1}
        @click=${(event) => this.dateClicked(event, day)}
        @focus=${() => this.changeRangePreview(day.date)}
        @blur=${() => this.clearRangePreview()}
        @keydown=${(event) => this.dateKeyDown(event, day)}
        @mouseenter=${() => this.changeRangePreview(day.date)}
        @mouseleave=${() => this.clearRangePreview()}
        >${this.formattedDate(day.date)}</span
      >
    </span>`;
    }
    render() {
        return html `${this.renderWeekHeaders()} ${this.renderDates()}`;
    }
};
IgcDaysViewComponent.tagName = 'igc-days-view';
IgcDaysViewComponent.styles = styles;
__decorate([
    query('[tabindex="0"]')
], IgcDaysViewComponent.prototype, "activeDay", void 0);
__decorate([
    property({ type: Boolean, attribute: 'hide-leading-days' })
], IgcDaysViewComponent.prototype, "hideLeadingDays", void 0);
__decorate([
    property({ type: Boolean, attribute: 'hide-trailing-days' })
], IgcDaysViewComponent.prototype, "hideTrailingDays", void 0);
__decorate([
    property({ type: Boolean })
], IgcDaysViewComponent.prototype, "active", void 0);
__decorate([
    property({ attribute: false })
], IgcDaysViewComponent.prototype, "rangePreviewDate", void 0);
__decorate([
    property({ attribute: 'week-day-format' })
], IgcDaysViewComponent.prototype, "weekDayFormat", void 0);
__decorate([
    property({ attribute: false })
], IgcDaysViewComponent.prototype, "resourceStrings", void 0);
__decorate([
    watch('weekDayFormat'),
    watch('locale')
], IgcDaysViewComponent.prototype, "formattersChange", null);
__decorate([
    watch('weekStart'),
    watch('activeDate')
], IgcDaysViewComponent.prototype, "datesChange", null);
IgcDaysViewComponent = IgcDaysViewComponent_1 = __decorate([
    blazorSuppressComponent,
    blazorIndirectRender,
    themes(all)
], IgcDaysViewComponent);
export default IgcDaysViewComponent;
//# sourceMappingURL=days-view.js.map