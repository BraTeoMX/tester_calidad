export var DateRangeType;
(function (DateRangeType) {
    DateRangeType[DateRangeType["After"] = 0] = "After";
    DateRangeType[DateRangeType["Before"] = 1] = "Before";
    DateRangeType[DateRangeType["Between"] = 2] = "Between";
    DateRangeType[DateRangeType["Specific"] = 3] = "Specific";
    DateRangeType[DateRangeType["Weekdays"] = 4] = "Weekdays";
    DateRangeType[DateRangeType["Weekends"] = 5] = "Weekends";
})(DateRangeType || (DateRangeType = {}));
export var TimeDeltaInterval;
(function (TimeDeltaInterval) {
    TimeDeltaInterval[TimeDeltaInterval["Second"] = 0] = "Second";
    TimeDeltaInterval[TimeDeltaInterval["Minute"] = 1] = "Minute";
    TimeDeltaInterval[TimeDeltaInterval["Hour"] = 2] = "Hour";
    TimeDeltaInterval[TimeDeltaInterval["Day"] = 3] = "Day";
    TimeDeltaInterval[TimeDeltaInterval["Week"] = 4] = "Week";
    TimeDeltaInterval[TimeDeltaInterval["Month"] = 5] = "Month";
    TimeDeltaInterval[TimeDeltaInterval["Quarter"] = 6] = "Quarter";
    TimeDeltaInterval[TimeDeltaInterval["Year"] = 7] = "Year";
})(TimeDeltaInterval || (TimeDeltaInterval = {}));
const MDAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const FEBRUARY = 1;
export const range = (start, stop, step = 1) => {
    const res = [];
    const beginning = start ?? 0;
    const cur = stop === undefined ? 0 : beginning;
    const max = stop === undefined ? beginning : stop;
    for (let i = cur; step < 0 ? i > max : i < max; i += step) {
        res.push(i);
    }
    return res;
};
export const isLeap = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
export const weekDay = (year, month, day) => new Date(year, month, day).getDay();
export const monthRange = (year, month) => {
    if (month < 0 || month > 11) {
        throw new Error('Invalid month specified');
    }
    const day = weekDay(year, month, 1);
    let nDays = MDAYS[month];
    if (month === FEBRUARY && isLeap(year)) {
        nDays++;
    }
    return [day, nDays];
};
export const isDateInRanges = (date, ranges) => {
    const searchedDate = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    const searchedDateInMs = searchedDate.getTime();
    if (!ranges) {
        return false;
    }
    for (const descriptor of ranges) {
        const dRanges = descriptor.dateRange
            ? descriptor.dateRange.map((r) => new Date(r.getFullYear(), r.getMonth(), r.getDate()))
            : [];
        switch (descriptor.type) {
            case DateRangeType.After:
                if (searchedDateInMs > dRanges[0].getTime()) {
                    return true;
                }
                break;
            case DateRangeType.Before:
                if (searchedDateInMs < dRanges[0].getTime()) {
                    return true;
                }
                break;
            case DateRangeType.Between: {
                const dRange = dRanges.map((d) => d.getTime());
                const min = Math.min(dRange[0], dRange[1]);
                const max = Math.max(dRange[0], dRange[1]);
                if (searchedDateInMs >= min && searchedDateInMs <= max) {
                    return true;
                }
                break;
            }
            case DateRangeType.Specific: {
                const datesInMs = dRanges.map((d) => d.getTime());
                for (const specificDateInMs of datesInMs) {
                    if (searchedDateInMs === specificDateInMs) {
                        return true;
                    }
                }
                break;
            }
            case DateRangeType.Weekdays: {
                const day = searchedDate.getDay();
                if (day % 6 !== 0) {
                    return true;
                }
                break;
            }
            case DateRangeType.Weekends: {
                const weekday = searchedDate.getDay();
                if (weekday % 6 === 0) {
                    return true;
                }
                break;
            }
            default:
                return false;
        }
    }
    return false;
};
export var WEEKDAYS;
(function (WEEKDAYS) {
    WEEKDAYS[WEEKDAYS["SUNDAY"] = 0] = "SUNDAY";
    WEEKDAYS[WEEKDAYS["MONDAY"] = 1] = "MONDAY";
    WEEKDAYS[WEEKDAYS["TUESDAY"] = 2] = "TUESDAY";
    WEEKDAYS[WEEKDAYS["WEDNESDAY"] = 3] = "WEDNESDAY";
    WEEKDAYS[WEEKDAYS["THURSDAY"] = 4] = "THURSDAY";
    WEEKDAYS[WEEKDAYS["FRIDAY"] = 5] = "FRIDAY";
    WEEKDAYS[WEEKDAYS["SATURDAY"] = 6] = "SATURDAY";
})(WEEKDAYS || (WEEKDAYS = {}));
export class Calendar {
    constructor(firstWeekDay = WEEKDAYS.SUNDAY) {
        this._firstWeekDay = firstWeekDay;
    }
    get firstWeekDay() {
        return this._firstWeekDay % 7;
    }
    set firstWeekDay(value) {
        this._firstWeekDay = value;
    }
    weekdays() {
        const res = [];
        for (const i of range(this.firstWeekDay, this.firstWeekDay + 7)) {
            res.push(i % 7);
        }
        return res;
    }
    monthdates(year, month, extraWeek = false) {
        let date = new Date(year, month, 1);
        let days = (date.getDay() - this.firstWeekDay) % 7;
        if (days < 0) {
            days = 7 - Math.abs(days);
        }
        date = this.timedelta(date, TimeDeltaInterval.Day, -days);
        const res = [];
        let value;
        while (true) {
            value = this.generateICalendarDate(date, year, month);
            res.push(value);
            date = this.timedelta(date, TimeDeltaInterval.Day, 1);
            if (date.getMonth() !== month && date.getDay() === this.firstWeekDay) {
                if (extraWeek && res.length <= 35) {
                    for (const _ of range(0, 7)) {
                        value = this.generateICalendarDate(date, year, month);
                        res.push(value);
                        date = this.timedelta(date, TimeDeltaInterval.Day, 1);
                    }
                }
                break;
            }
        }
        return res;
    }
    monthdatescalendar(year, month, extraWeek = false) {
        const dates = this.monthdates(year, month, extraWeek);
        const res = [];
        for (const i of range(0, dates.length, 7)) {
            res.push(dates.slice(i, i + 7));
        }
        return res;
    }
    timedelta(date, interval, units) {
        const ret = new Date(date);
        const checkRollover = () => {
            if (ret.getDate() !== date.getDate()) {
                ret.setDate(0);
            }
        };
        switch (interval) {
            case TimeDeltaInterval.Year:
                ret.setFullYear(ret.getFullYear() + units);
                checkRollover();
                break;
            case TimeDeltaInterval.Quarter:
                ret.setMonth(ret.getMonth() + 3 * units);
                checkRollover();
                break;
            case TimeDeltaInterval.Month:
                ret.setMonth(ret.getMonth() + units);
                checkRollover();
                break;
            case TimeDeltaInterval.Week:
                ret.setDate(ret.getDate() + 7 * units);
                break;
            case TimeDeltaInterval.Day:
                ret.setDate(ret.getDate() + units);
                break;
            case TimeDeltaInterval.Hour:
                ret.setTime(ret.getTime() + units * 3600000);
                break;
            case TimeDeltaInterval.Minute:
                ret.setTime(ret.getTime() + units * 60000);
                break;
            case TimeDeltaInterval.Second:
                ret.setTime(ret.getTime() + units * 1000);
                break;
            default:
                throw new Error('Invalid interval specifier');
        }
        return ret;
    }
    getNextMonth(date) {
        return this.timedelta(date, TimeDeltaInterval.Month, 1);
    }
    getPrevMonth(date) {
        return this.timedelta(date, TimeDeltaInterval.Month, -1);
    }
    getNextYear(date) {
        return this.timedelta(date, TimeDeltaInterval.Year, 1);
    }
    getPrevYear(date) {
        return this.timedelta(date, TimeDeltaInterval.Year, -1);
    }
    getWeekNumber(date) {
        const firstJan = new Date(date.getFullYear(), 0, 1).getTime();
        const today = new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime();
        const dayInMilSeconds = 86400000;
        const dayOfYear = (today - firstJan + 1) / dayInMilSeconds;
        return Math.ceil(dayOfYear / 7);
    }
    generateICalendarDate(date, year, month) {
        return {
            date,
            isCurrentMonth: date.getFullYear() === year && date.getMonth() === month,
            isNextMonth: this.isNextMonth(date, year, month),
            isPrevMonth: this.isPreviousMonth(date, year, month),
        };
    }
    isPreviousMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() < month;
        }
        return date.getFullYear() < year;
    }
    isNextMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() > month;
        }
        return date.getFullYear() > year;
    }
}
//# sourceMappingURL=calendar.model.js.map