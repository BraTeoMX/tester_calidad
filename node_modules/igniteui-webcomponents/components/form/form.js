var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { LitElement, css, html } from 'lit';
import { property } from 'lit/decorators.js';
import { alternateName } from '../common/decorators/alternateName.js';
import { blazorSuppress } from '../common/decorators/blazorSuppress.js';
import { registerComponent } from '../common/definitions/register.js';
import { EventEmitterMixin } from '../common/mixins/event-emitter.js';
class IgcFormComponent extends EventEmitterMixin(LitElement) {
    static register() {
        registerComponent(IgcFormComponent);
    }
    constructor() {
        super();
        this._controlsWithChecked = [
            'input',
            'radio',
            'igc-radio',
            'igc-switch',
            'igc-checkbox',
        ];
        this._controlsWithValue = [
            'input',
            'igc-input',
            'igc-mask-input',
            'textarea',
            'igc-rating',
            'igc-select',
            'igc-combo',
            'igc-date-time-input',
        ];
        this._controlsThatSubmit = [
            'input',
            'button',
            'igc-button',
            'igc-icon-button',
        ];
        this.novalidate = false;
        this.addEventListener('click', this.handleClick);
    }
    submit() {
        const formData = this.getFormData();
        if (!this.novalidate && !this.reportValidity()) {
            return false;
        }
        this.emitEvent('igcSubmit', { detail: formData });
        return true;
    }
    reset() {
        const formElements = this.getFormElements();
        formElements.forEach((element) => {
            const tagName = element.tagName.toLowerCase();
            if (tagName === 'select') {
                for (let i = 0; i < element.options.length; i++) {
                    const option = element.options[i];
                    option.selected = option.defaultSelected;
                }
            }
            else if ((tagName === 'input' &&
                (element.type === 'checkbox' || element.type === 'radio')) ||
                (tagName !== 'input' && this._controlsWithChecked.includes(tagName))) {
                element.checked = element.hasAttribute('checked');
            }
            else if (tagName === 'igc-input' ||
                tagName === 'igc-rating' ||
                tagName === 'igc-mask-input' ||
                tagName === 'igc-date-time-input') {
                element.value = element.getAttribute('value');
            }
            else if (this._controlsWithValue.includes(tagName)) {
                element.value = element.defaultValue;
            }
        });
        this.emitEvent('igcReset');
    }
    getFormElements() {
        const slot = this.shadowRoot?.querySelector('slot');
        const assignedElements = slot?.assignedElements({ flatten: true });
        const formElements = [];
        assignedElements?.forEach((element) => {
            if (!element.disabled) {
                formElements.push(element);
            }
            const children = Array.from(element.getElementsByTagName('*')).filter((element) => !element.disabled);
            formElements.push(...children);
        });
        return formElements;
    }
    getFormData() {
        const formData = new FormData();
        const formElements = this.getFormElements();
        formElements.forEach((element) => {
            const tagName = element.tagName.toLowerCase();
            if (tagName === 'select') {
                for (let i = 0; i < element.options.length; i++) {
                    const option = element.options[i];
                    if (option.selected) {
                        formData.append(element.name, option.value);
                    }
                }
            }
            else if (this._controlsWithChecked.includes(tagName) &&
                element.checked) {
                formData.append(element.name, element.value || 'on');
            }
            else if (this._controlsWithValue.includes(tagName) &&
                element.type !== 'checkbox' &&
                element.type !== 'radio' &&
                element.type !== 'submit') {
                formData.append(element.name, element.value);
            }
        });
        return formData;
    }
    reportValidity() {
        const formElements = this.getFormElements();
        return !formElements.some((element) => typeof element.reportValidity === 'function' &&
            element.reportValidity() === false);
    }
    handleClick(event) {
        const targetElement = event.target;
        if (this._controlsThatSubmit.includes(targetElement.tagName.toLowerCase()) &&
            targetElement.type?.toLowerCase() === 'submit') {
            this.submit();
        }
        else if (targetElement.type?.toLowerCase() === 'reset') {
            this.reset();
        }
        return true;
    }
    render() {
        return html `<slot></slot>`;
    }
}
IgcFormComponent.tagName = 'igc-form';
IgcFormComponent.styles = css `
    :host {
      display: block;
    }
  `;
export default IgcFormComponent;
__decorate([
    property({ type: Boolean, reflect: true })
], IgcFormComponent.prototype, "novalidate", void 0);
__decorate([
    alternateName('performSubmit')
], IgcFormComponent.prototype, "submit", null);
__decorate([
    alternateName('performReset')
], IgcFormComponent.prototype, "reset", null);
__decorate([
    blazorSuppress()
], IgcFormComponent.prototype, "getFormData", null);
//# sourceMappingURL=form.js.map