{"version":3,"file":"mutation-observer.js","sourceRoot":"","sources":["../../../../src/components/common/controllers/mutation-observer.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ReactiveController, ReactiveControllerHost } from 'lit';\n\nimport { isElement } from '../util.js';\n\nexport interface MutationControllerConfig<T> {\n  /** The callback function to run when a mutation occurs. */\n  callback: MutationControllerCallback<T>;\n  /** The underlying mutation observer configuration parameters. */\n  config: MutationObserverInit;\n  /**\n   * The element to observe.\n   * If left out, the observer will listen on the host component itself.\n   */\n  target?: Element;\n  /**\n   * A filter configuration.\n   * See {@link MutationControllerFilter|this} for additional information.\n   */\n  filter?: MutationControllerFilter<T>;\n}\n\ntype MutationControllerCallback<T> = (\n  params: MutationControllerParams<T>\n) => unknown;\n\n/**\n * Filter configuration to return elements that either match\n * an array of selector strings or a predicate function.\n */\ntype MutationControllerFilter<T> = string[] | ((node: T) => boolean);\n\ntype MutationChange<T> = {\n  /** Elements that have attribute(s) changes. */\n  attributes: T[];\n  /** Elements that have been added. */\n  added: T[];\n  /** Elements that have been removed. */\n  removed: T[];\n};\n\nexport type MutationControllerParams<T> = {\n  /** The original mutation records from the underlying observer. */\n  records: MutationRecord[];\n  /** The aggregated changes. */\n  changes: MutationChange<T>;\n  /** The observer controller instance. */\n  observer: MutationController<T>;\n};\n\nfunction mutationFilter<T>(nodes: T[], filter?: MutationControllerFilter<T>) {\n  if (!filter) {\n    return nodes;\n  }\n\n  return Array.isArray(filter)\n    ? nodes.filter((node) =>\n        filter.some((selector) => isElement(node) && node.matches(selector))\n      )\n    : nodes.filter((node) => filter(node));\n}\n\nclass MutationController<T> implements ReactiveController {\n  private _host: ReactiveControllerHost & Element;\n  private _observer: MutationObserver;\n  private _target: Element;\n  private _config: MutationObserverInit;\n  private _callback: MutationControllerCallback<T>;\n  private _filter?: MutationControllerFilter<T>;\n\n  constructor(\n    host: ReactiveControllerHost & Element,\n    options: MutationControllerConfig<T>\n  ) {\n    this._host = host;\n    this._callback = options.callback;\n    this._config = options.config;\n    this._target = options.target ?? this._host;\n    this._filter = options.filter ?? [];\n\n    this._observer = new MutationObserver((records) => {\n      this.disconnect();\n      this._callback.call(this._host, this._process(records));\n      this.observe();\n    });\n\n    host.addController(this);\n  }\n\n  public hostConnected() {\n    this.observe();\n  }\n\n  public hostDisconnected() {\n    this.disconnect();\n  }\n\n  private _process(records: MutationRecord[]): MutationControllerParams<T> {\n    const changes: MutationChange<T> = {\n      attributes: [],\n      added: [],\n      removed: [],\n    };\n    const filter = this._filter;\n\n    for (const record of records) {\n      if (record.type === 'attributes') {\n        changes.attributes.push(\n          ...mutationFilter([record.target as T], filter)\n        );\n      } else if (record.type === 'childList') {\n        changes.added.push(\n          ...mutationFilter(Array.from(record.addedNodes) as T[], filter)\n        );\n        changes.removed.push(\n          ...mutationFilter(Array.from(record.removedNodes) as T[], filter)\n        );\n      }\n    }\n\n    return { records, changes, observer: this };\n  }\n\n  /**\n   * Begin receiving notifications of changes to the DOM based\n   * on the configured {@link MutationControllerConfig.target|target} and observer {@link MutationControllerConfig.config|options}.\n   */\n  public observe() {\n    this._observer.observe(this._target, this._config);\n  }\n\n  /** Stop watching for mutations. */\n  public disconnect() {\n    this._observer.disconnect();\n  }\n}\n\n/**\n * Creates and attaches a mutation controller with `config` to the passed in `host`.\n *\n * Automatically starts/stops observing for mutation changes\n * in the respective component connect/disconnect callbacks.\n *\n * The mutation observer is disconnected before invoking the passed in callback and re-attached\n * after that in order to not loop itself in endless stream of changes.\n */\nexport function createMutationController<T>(\n  host: ReactiveControllerHost & Element,\n  config: MutationControllerConfig<T>\n) {\n  return new MutationController(host, config);\n}\n"]}