{"version":3,"file":"util.js","sourceRoot":"","sources":["../../../src/components/common/util.ts"],"names":[],"mappings":"AAIA,MAAM,CAAC,MAAM,WAAW,GAAG,CAAC,YAA0B,EAAE,EAAE;IACxD,OAAO,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC;SAC7B,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;SAClC,IAAI,CAAC,GAAG,CAAC,CAAC;AACf,CAAC,CAAC;AAEF,MAAM,UAAU,IAAI,KAAI,CAAC;AAEzB,MAAM,CAAC,MAAM,SAAS,GAAG,CAAC,IAAY,EAAE,KAAa,EAAE,EAAE,CAAC,CAAC,IAAI,GAAG,KAAK,CAAC,GAAG,GAAG,CAAC;AAE/E,MAAM,CAAC,MAAM,KAAK,GAAG,CAAC,MAAc,EAAE,GAAW,EAAE,GAAW,EAAE,EAAE,CAChE,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,CAAC;AAavC,MAAM,UAAU,SAAS,CAAC,OAAoB,EAAE,MAAmB;IACjE,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,OAAO,CAAC,qBAAqB,EAAE,CAAC;IACrE,MAAM,EACJ,GAAG,EAAE,IAAI,EACT,IAAI,EAAE,KAAK,EACX,MAAM,EAAE,OAAO,EACf,KAAK,EAAE,MAAM,GACd,GAAG,MAAM,CAAC,qBAAqB,EAAE,CAAC;IAEnC,OAAO;QACL,GAAG,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC;QAC3B,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,KAAK,CAAC;QAC9B,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,MAAM,CAAC;QACjC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,OAAO,CAAC;KACrC,CAAC;AACJ,CAAC;AAED,MAAM,UAAU,aAAa;IAC3B,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,OAAO,GAAG,EAAE;QACV,CAAC,EAAE,CAAC;QACJ,OAAO,CAAC,CAAC;IACX,CAAC,CAAC;AACJ,CAAC;AAKD,MAAM,UAAU,KAAK,CAAC,OAAoB;IACxC,OAAO,OAAO,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;AACtC,CAAC;AAYD,MAAM,UAAU,YAAY,CAAC,QAAgB,EAAE,GAAG,MAAiB;IACjE,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;IAE7B,OAAO,QAAQ,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,KAAa,EAAE,KAAa,EAAE,EAAE,CACnE,KAAK,IAAI,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,EAAE,CAC7C,CAAC;AACJ,CAAC;AAaD,MAAM,UAAU,QAAQ,CAAC,KAAc,EAAE,QAAQ,GAAG,CAAC;IACnD,MAAM,MAAM,GAAG,MAAM,CAAC,UAAU,CAAC,KAAe,CAAC,CAAC;IAClD,OAAO,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC;AAClD,CAAC;AAeD,MAAM,UAAU,IAAI,CAAC,GAAW,EAAE,GAAW,EAAE,KAAa;IAC1D,IAAI,KAAK,GAAG,GAAG,EAAE,CAAC;QAChB,OAAO,GAAG,CAAC;IACb,CAAC;IACD,IAAI,KAAK,GAAG,GAAG,EAAE,CAAC;QAChB,OAAO,GAAG,CAAC;IACb,CAAC;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AAED,MAAM,UAAU,SAAS,CAAc,KAAQ;IAC7C,OAAO,KAAK,KAAK,SAAS,CAAC;AAC7B,CAAC;AAED,MAAM,SAAS,CAAC,CAAC,SAAS,CACxB,IAAU,EACV,UAAoC,EACpC,MAA6B;IAE7B,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE,CAAC;QACpC,OAAO;IACT,CAAC;IAED,MAAM,IAAI,GAAG,UAAU,CAAC,QAAQ,CAAC,gBAAgB,CAC/C,IAAI,EACJ,UAAU,CAAC,UAAU,IAAI,UAAU,CAAC,CACrC,CAAC;IAEF,IAAI,IAAI,GAAG,IAAI,CAAC,QAAQ,EAAO,CAAC;IAEhC,OAAO,IAAI,EAAE,CAAC;QACZ,IAAI,MAAM,EAAE,CAAC;YACX,IAAI,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC;gBACjB,MAAM,IAAI,CAAC;YACb,CAAC;QACH,CAAC;aAAM,CAAC;YACN,MAAM,IAAI,CAAC;QACb,CAAC;QAED,IAAI,GAAG,IAAI,CAAC,QAAQ,EAAO,CAAC;IAC9B,CAAC;AACH,CAAC;AAED,MAAM,UAAU,sBAAsB,CAAC,IAAiB,EAAE,EAAU;IAClE,OAAQ,IAAI,CAAC,WAAW,EAA4B,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC;AAC1E,CAAC;AAED,MAAM,UAAU,SAAS,CAAC,IAAa;IACrC,OAAO,IAAI,YAAY,IAAI,IAAI,IAAI,CAAC,QAAQ,KAAK,IAAI,CAAC,YAAY,CAAC;AACrE,CAAC;AAED,MAAM,UAAU,wBAAwB,CAAoB,KAAY;IACtE,OAAO,KAAK,CAAC,YAAY,EAAE,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,CAAQ,CAAC;AACvE,CAAC;AAED,MAAM,UAAU,wBAAwB,CACtC,SAAmD,EACnD,KAAY;IAEZ,MAAM,IAAI,GACR,OAAO,SAAS,KAAK,QAAQ;QAC3B,CAAC,CAAC,CAAC,CAAU,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC;QACtC,CAAC,CAAC,CAAC,CAAU,EAAE,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;IAEnC,OAAO,wBAAwB,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,IAAI,CAAkB,CAAC;AACrE,CAAC;AAED,MAAM,UAAU,OAAO,CAAI,KAAU,EAAE,GAAiC;IACtE,MAAM,MAAM,GAAwB,EAAE,CAAC;IACvC,MAAM,IAAI,GAAG,OAAO,GAAG,KAAK,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAO,EAAE,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAEtE,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;QACzB,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC;QAC5B,MAAM,KAAK,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;QAE/B,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;YACzB,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACnB,CAAC;aAAM,CAAC;YACN,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAC5B,CAAC;IACH,CAAC;IAED,OAAO,MAAM,CAAC;AAChB,CAAC","sourcesContent":["export interface PartNameInfo {\n  readonly [name: string]: string | boolean | number;\n}\n\nexport const partNameMap = (partNameInfo: PartNameInfo) => {\n  return Object.keys(partNameInfo)\n    .filter((key) => partNameInfo[key])\n    .join(' ');\n};\n\nexport function noop() {}\n\nexport const asPercent = (part: number, whole: number) => (part / whole) * 100;\n\nexport const clamp = (number: number, min: number, max: number) =>\n  Math.max(min, Math.min(number, max));\n\n/**\n *\n * Returns an element's offset relative to its parent. Similar to element.offsetTop and element.offsetLeft, except the\n * parent doesn't have to be positioned relative or absolute.\n *\n * Work around for the following issues in Chromium based browsers:\n *\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1330819\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1334556\n *\n */\nexport function getOffset(element: HTMLElement, parent: HTMLElement) {\n  const { top, left, bottom, right } = element.getBoundingClientRect();\n  const {\n    top: pTop,\n    left: pLeft,\n    bottom: pBottom,\n    right: pRight,\n  } = parent.getBoundingClientRect();\n\n  return {\n    top: Math.round(top - pTop),\n    left: Math.round(left - pLeft),\n    right: Math.round(right - pRight),\n    bottom: Math.round(bottom - pBottom),\n  };\n}\n\nexport function createCounter() {\n  let i = 0;\n  return () => {\n    i++;\n    return i;\n  };\n}\n\n/**\n * Returns whether an element has a Left-to-Right directionality.\n */\nexport function isLTR(element: HTMLElement) {\n  return element.matches(':dir(ltr)');\n}\n\n/**\n * Builds a string from format specifiers and replacement parameters.\n * Will coerce non-string parameters to their string representations.\n *\n * @example\n * ```typescript\n * formatString('{0} says \"{1}\".', 'John', 'Hello'); // 'John says \"Hello\".'\n * formatString('{1} is greater than {0}', 0, 1); // '1 is greater than 0'\n * ```\n */\nexport function formatString(template: string, ...params: unknown[]): string {\n  const length = params.length;\n\n  return template.replace(/{(\\d+)}/g, (match: string, index: number) =>\n    index >= length ? match : `${params[index]}`\n  );\n}\n\n/**\n * Parse the passed `value` as a number or return the `fallback` if it can't be done.\n *\n * @example\n * ```typescript\n * asNumber('5'); // 5\n * asNumber('3.14'); // 3.14\n * asNumber('five'); // 0\n * asNUmber('five', 5); // 5\n * ```\n */\nexport function asNumber(value: unknown, fallback = 0) {\n  const parsed = Number.parseFloat(value as string);\n  return Number.isNaN(parsed) ? fallback : parsed;\n}\n\n/**\n * Returns the value wrapped between the min and max bounds.\n *\n * If the value is greater than max, returns the min and vice-versa.\n * If the value is between the bounds, it is returned unchanged.\n *\n * @example\n * ```typescript\n * wrap(1, 4, 2); // 2\n * wrap(1, 4, 5); // 1\n * wrap(1, 4, -1); // 4\n * ```\n */\nexport function wrap(min: number, max: number, value: number) {\n  if (value < min) {\n    return max;\n  }\n  if (value > max) {\n    return min;\n  }\n\n  return value;\n}\n\nexport function isDefined<T = unknown>(value: T) {\n  return value !== undefined;\n}\n\nexport function* iterNodes<T = Node>(\n  root: Node,\n  whatToShow?: keyof typeof NodeFilter,\n  filter?: (node: T) => boolean\n): Generator<T> {\n  if (!isDefined(globalThis.document)) {\n    return;\n  }\n\n  const iter = globalThis.document.createTreeWalker(\n    root,\n    NodeFilter[whatToShow ?? 'SHOW_ALL']\n  );\n\n  let node = iter.nextNode() as T;\n\n  while (node) {\n    if (filter) {\n      if (filter(node)) {\n        yield node;\n      }\n    } else {\n      yield node;\n    }\n\n    node = iter.nextNode() as T;\n  }\n}\n\nexport function getElementByIdFromRoot(root: HTMLElement, id: string) {\n  return (root.getRootNode() as Document | ShadowRoot).getElementById(id);\n}\n\nexport function isElement(node: unknown): node is Element {\n  return node instanceof Node && node.nodeType === Node.ELEMENT_NODE;\n}\n\nexport function getElementsFromEventPath<T extends Element>(event: Event) {\n  return event.composedPath().filter((item) => isElement(item)) as T[];\n}\n\nexport function findElementFromEventPath<T extends Element>(\n  predicate: string | ((element: Element) => boolean),\n  event: Event\n) {\n  const func =\n    typeof predicate === 'string'\n      ? (e: Element) => e.matches(predicate)\n      : (e: Element) => predicate(e);\n\n  return getElementsFromEventPath(event).find(func) as T | undefined;\n}\n\nexport function groupBy<T>(array: T[], key: keyof T | ((item: T) => any)) {\n  const result: Record<string, T[]> = {};\n  const _get = typeof key === 'function' ? key : (item: T) => item[key];\n\n  for (const item of array) {\n    const category = _get(item);\n    const group = result[category];\n\n    if (Array.isArray(group)) {\n      group.push(item);\n    } else {\n      result[category] = [item];\n    }\n  }\n\n  return result;\n}\n"]}