{"version":3,"file":"event-emitter.js","sourceRoot":"","sources":["../../../../src/components/common/mixins/event-emitter.ts"],"names":[],"mappings":"AAsCA,MAAM,UAAU,iBAAiB,CAC/B,UAAa;IAEb,MAAM,mBAAoB,SAAQ,UAAU;QAY1B,gBAAgB,CAC9B,IAAY,EACZ,QAA4C,EAC5C,OAA2C;YAE3C,KAAK,CAAC,gBAAgB,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;QAClD,CAAC;QAae,mBAAmB,CACjC,IAAY,EACZ,QAA4C,EAC5C,OAAwC;YAExC,KAAK,CAAC,mBAAmB,CAAC,IAAI,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;QACrD,CAAC;QAKM,SAAS,CACd,IAAO,EACP,aAAkC;YAElC,OAAO,IAAI,CAAC,aAAa,CACvB,IAAI,WAAW,CACb,IAAc,EACd,MAAM,CAAC,MAAM,CACX;gBACE,OAAO,EAAE,IAAI;gBACb,UAAU,EAAE,KAAK;gBACjB,QAAQ,EAAE,IAAI;gBACd,MAAM,EAAE,EAAE;aACX,EACD,aAAa,CACd,CACF,CACF,CAAC;QACJ,CAAC;KACF;IACD,OAAO,mBAAgE,CAAC;AAC1E,CAAC","sourcesContent":["import type { LitElement } from 'lit';\nimport type { AbstractConstructor, Constructor } from './constructor.js';\n\nexport type UnpackCustomEvent<T> = T extends CustomEvent<infer U> ? U : never;\n\nexport declare class EventEmitterInterface<E> {\n  public addEventListener<K extends keyof M, M extends E & HTMLElementEventMap>(\n    type: K,\n    listener: (this: HTMLElement, ev: M[K]) => any,\n    options?: boolean | AddEventListenerOptions\n  ): void;\n  public addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions\n  ): void;\n  public removeEventListener<\n    K extends keyof M,\n    M extends E & HTMLElementEventMap,\n  >(\n    type: K,\n    listener: (this: HTMLElement, ev: M[K]) => any,\n    options?: boolean | EventListenerOptions\n  ): void;\n  public removeEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | EventListenerOptions\n  ): void;\n  public emitEvent<K extends keyof E, D extends UnpackCustomEvent<E[K]>>(\n    type: K,\n    eventInitDict?: CustomEventInit<D>\n  ): boolean;\n}\n\nexport function EventEmitterMixin<E, T extends AbstractConstructor<LitElement>>(\n  superClass: T\n): Constructor<EventEmitterInterface<E>> & T;\nexport function EventEmitterMixin<E, T extends Constructor<LitElement>>(\n  superClass: T\n) {\n  class EventEmitterElement extends superClass {\n    /**\n     * @private\n     */\n    public override addEventListener<\n      K extends keyof M,\n      M extends E & HTMLElementEventMap,\n    >(\n      type: K,\n      listener: (this: HTMLElement, ev: M[K]) => any,\n      options?: boolean | AddEventListenerOptions\n    ): void;\n    public override addEventListener(\n      type: string,\n      listener: EventListenerOrEventListenerObject,\n      options?: boolean | AddEventListenerOptions\n    ): void {\n      super.addEventListener(type, listener, options);\n    }\n\n    /**\n     * @private\n     */\n    public override removeEventListener<\n      K extends keyof M,\n      M extends E & HTMLElementEventMap,\n    >(\n      type: K,\n      listener: (this: HTMLElement, ev: M[K]) => any,\n      options?: boolean | EventListenerOptions\n    ): void;\n    public override removeEventListener(\n      type: string,\n      listener: EventListenerOrEventListenerObject,\n      options?: boolean | EventListenerOptions\n    ): void {\n      super.removeEventListener(type, listener, options);\n    }\n\n    /**\n     * @private\n     */\n    public emitEvent<K extends keyof E, D extends UnpackCustomEvent<E[K]>>(\n      type: K,\n      eventInitDict?: CustomEventInit<D>\n    ): boolean {\n      return this.dispatchEvent(\n        new CustomEvent<D>(\n          type as string,\n          Object.assign(\n            {\n              bubbles: true,\n              cancelable: false,\n              composed: true,\n              detail: {},\n            },\n            eventInitDict\n          )\n        )\n      );\n    }\n  }\n  return EventEmitterElement as Constructor<EventEmitterInterface<E>> & T;\n}\n"]}