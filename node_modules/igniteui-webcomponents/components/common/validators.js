import { DateTimeUtil } from '../date-time-input/date-util.js';
import validatorMessages from './localization/validation-en.js';
import { asNumber, formatString, isDefined } from './util.js';
const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
export const requiredValidator = {
    key: 'valueMissing',
    message: validatorMessages.required,
    isValid: ({ required, value }) => (required ? !!value : true),
};
export const requiredNumberValidator = {
    key: 'valueMissing',
    message: validatorMessages.required,
    isValid: ({ required, value }) => (required ? isDefined(value) : true),
};
export const requiredBooleanValidator = {
    key: 'valueMissing',
    message: validatorMessages.required,
    isValid: ({ required, checked }) => (required ? checked : true),
};
export const minLengthValidator = {
    key: 'tooShort',
    message: ({ minLength }) => formatString(validatorMessages.minLength, minLength),
    isValid: ({ minLength, value }) => minLength ? value.length >= minLength : true,
};
export const maxLengthValidator = {
    key: 'tooLong',
    message: ({ maxLength }) => formatString(validatorMessages.maxLength, maxLength),
    isValid: ({ maxLength, value }) => maxLength ? value.length <= maxLength : true,
};
export const patternValidator = {
    key: 'patternMismatch',
    message: validatorMessages.pattern,
    isValid: ({ pattern, value }) => pattern ? new RegExp(pattern, 'u').test(value) : true,
};
export const minValidator = {
    key: 'rangeUnderflow',
    message: ({ min }) => formatString(validatorMessages.min, min),
    isValid: ({ min, value }) => isDefined(min)
        ? isDefined(value) && asNumber(value) >= asNumber(min)
        : true,
};
export const maxValidator = {
    key: 'rangeOverflow',
    message: ({ max }) => formatString(validatorMessages.max, max),
    isValid: ({ max, value }) => isDefined(max)
        ? isDefined(value) && asNumber(value) <= asNumber(max)
        : true,
};
export const stepValidator = {
    key: 'stepMismatch',
    message: 'Value does not conform to step constraint',
    isValid: ({ min, step, value }) => isDefined(step)
        ? (asNumber(value) - asNumber(min)) % asNumber(step, 1) === 0
        : true,
};
export const emailValidator = {
    key: 'typeMismatch',
    message: validatorMessages.email,
    isValid: ({ value }) => emailRegex.test(value),
};
export const urlValidator = {
    key: 'typeMismatch',
    message: validatorMessages.url,
    isValid: ({ value }) => URL.canParse(value),
};
export const minDateValidator = {
    key: 'rangeUnderflow',
    message: ({ min }) => formatString(validatorMessages.min, min),
    isValid: ({ value, min }) => min
        ? !DateTimeUtil.lessThanMinValue(value ?? new Date(), min, false, true)
        : true,
};
export const maxDateValidator = {
    key: 'rangeOverflow',
    message: ({ max }) => formatString(validatorMessages.max, max),
    isValid: ({ value, max }) => max
        ? !DateTimeUtil.greaterThanMaxValue(value ?? new Date(), max, false, true)
        : true,
};
//# sourceMappingURL=validators.js.map