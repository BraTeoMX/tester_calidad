{"version":3,"file":"svg.filter.min.js","sources":["../src/svg.filter.js"],"sourcesContent":["import {\n  Array as SVGArray,\n  Container,\n  Defs,\n  Element,\n  extend,\n  find,\n  namespaces as ns,\n  nodeOrNew,\n  utils,\n  wrapWithAttrCheck\n} from '@svgdotjs/svg.js'\n\nexport default class Filter extends Element {\n  constructor (node) {\n    super(nodeOrNew('filter', node), node)\n\n    this.$source = 'SourceGraphic'\n    this.$sourceAlpha = 'SourceAlpha'\n    this.$background = 'BackgroundImage'\n    this.$backgroundAlpha = 'BackgroundAlpha'\n    this.$fill = 'FillPaint'\n    this.$stroke = 'StrokePaint'\n    this.$autoSetIn = true\n  }\n\n  put (element, i) {\n    element = super.put(element, i)\n\n    if (!element.attr('in') && this.$autoSetIn) {\n      element.attr('in', this.$source)\n    }\n    if (!element.attr('result')) {\n      element.attr('result', element.id())\n    }\n\n    return element\n  }\n\n  // Unmask all masked elements and remove itself\n  remove () {\n    // unmask all targets\n    this.targets().each('unfilter')\n\n    // remove mask from parent\n    return super.remove()\n  }\n\n  targets () {\n    return find('svg [filter*=\"' + this.id() + '\"]')\n  }\n\n  toString () {\n    return 'url(#' + this.id() + ')'\n  }\n}\n\n// Create Effect class\nclass Effect extends Element {\n  constructor (node, attr) {\n    super(node, attr)\n    this.result(this.id())\n  }\n\n  in (effect) {\n    // Act as getter\n    if (effect == null) {\n      const _in = this.attr('in')\n      const ref = this.parent() && this.parent().find(`[result=\"${_in}\"]`)[0]\n      return ref || _in\n    }\n\n    // Avr as setter\n    return this.attr('in', effect)\n  }\n\n  // Named result\n  result (result) {\n    return this.attr('result', result)\n  }\n\n  // Stringification\n  toString () {\n    return this.result()\n  }\n}\n\n// This function takes an array with attr keys and sets for every key the\n// attribute to the value of one paramater\n// getAttrSetter(['a', 'b']) becomes this.attr({a: param1, b: param2})\nconst getAttrSetter = (params) => {\n  return function (...args) {\n    for (let i = params.length; i--;) {\n      if (args[i] != null) {\n        this.attr(params[i], args[i])\n      }\n    }\n  }\n}\n\nconst updateFunctions = {\n  blend: getAttrSetter(['in', 'in2', 'mode']),\n  // ColorMatrix effect\n  colorMatrix: getAttrSetter(['type', 'values']),\n  // Composite effect\n  composite: getAttrSetter(['in', 'in2', 'operator']),\n  // ConvolveMatrix effect\n  convolveMatrix: function (matrix) {\n    matrix = new SVGArray(matrix).toString()\n\n    this.attr({\n      order: Math.sqrt(matrix.split(' ').length),\n      kernelMatrix: matrix\n    })\n  },\n  // DiffuseLighting effect\n  diffuseLighting: getAttrSetter(['surfaceScale', 'lightingColor', 'diffuseConstant', 'kernelUnitLength']),\n  // DisplacementMap effect\n  displacementMap: getAttrSetter(['in', 'in2', 'scale', 'xChannelSelector', 'yChannelSelector']),\n  // DropShadow effect\n  dropShadow: getAttrSetter(['in', 'dx', 'dy', 'stdDeviation']),\n  // Flood effect\n  flood: getAttrSetter(['flood-color', 'flood-opacity']),\n  // Gaussian Blur effect\n  gaussianBlur: function (x = 0, y = x) {\n    this.attr('stdDeviation', x + ' ' + y)\n  },\n  // Image effect\n  image: function (src) {\n    this.attr('href', src, ns.xlink)\n  },\n  // Morphology effect\n  morphology: getAttrSetter(['operator', 'radius']),\n  // Offset effect\n  offset: getAttrSetter(['dx', 'dy']),\n  // SpecularLighting effect\n  specularLighting: getAttrSetter(['surfaceScale', 'lightingColor', 'diffuseConstant', 'specularExponent', 'kernelUnitLength']),\n  // Tile effect\n  tile: getAttrSetter([]),\n  // Turbulence effect\n  turbulence: getAttrSetter(['baseFrequency', 'numOctaves', 'seed', 'stitchTiles', 'type'])\n}\n\nconst filterNames = [\n  'blend',\n  'colorMatrix',\n  'componentTransfer',\n  'composite',\n  'convolveMatrix',\n  'diffuseLighting',\n  'displacementMap',\n  'dropShadow',\n  'flood',\n  'gaussianBlur',\n  'image',\n  'merge',\n  'morphology',\n  'offset',\n  'specularLighting',\n  'tile',\n  'turbulence'\n]\n\n// For every filter create a class\nfilterNames.forEach((effect) => {\n  const name = utils.capitalize(effect)\n  const fn = updateFunctions[effect]\n\n  Filter[name + 'Effect'] = class extends Effect {\n    constructor (node) {\n      super(nodeOrNew('fe' + name, node), node)\n    }\n\n    // This function takes all parameters from the factory call\n    // and updates the attributes according to the updateFunctions\n    update (args) {\n      fn.apply(this, args)\n      return this\n    }\n  }\n\n  // Add factory function to filter\n  // Allow to pass a function or object\n  // The attr object is catched from \"wrapWithAttrCheck\"\n  Filter.prototype[effect] = wrapWithAttrCheck(function (fn, ...args) {\n    const effect = new Filter[name + 'Effect']()\n\n    if (fn == null) return this.put(effect)\n\n    // For Effects which can take children, a function is allowed\n    if (typeof fn === 'function') {\n      fn.call(effect, effect)\n    } else {\n      // In case it is not a function, add it to arguments\n      args.unshift(fn)\n    }\n    return this.put(effect).update(args)\n  })\n})\n\n// Correct factories which are not that simple\nextend(Filter, {\n  merge (arrayOrFn) {\n    const node = this.put(new Filter.MergeEffect())\n\n    // If a function was passed, execute it\n    // That makes stuff like this possible:\n    // filter.merge((mergeEffect) => mergeEffect.mergeNode(in))\n    if (typeof arrayOrFn === 'function') {\n      arrayOrFn.call(node, node)\n      return node\n    }\n\n    // Check if first child is an array, otherwise use arguments as array\n    const children = arrayOrFn instanceof Array ? arrayOrFn : [...arguments]\n\n    children.forEach((child) => {\n      if (child instanceof Filter.MergeNode) {\n        node.put(child)\n      } else {\n        node.mergeNode(child)\n      }\n    })\n\n    return node\n  },\n  componentTransfer (components = {}) {\n    const node = this.put(new Filter.ComponentTransferEffect())\n\n    if (typeof components === 'function') {\n      components.call(node, node)\n      return node\n    }\n\n    // If no component is set, we use the given object for all components\n    if (!components.r && !components.g && !components.b && !components.a) {\n      const temp = components\n      components = {\n        r: temp, g: temp, b: temp, a: temp\n      }\n    }\n\n    for (const c in components) {\n      // components[c] has to hold an attributes object\n      node.add(new Filter['Func' + c.toUpperCase()](components[c]))\n    }\n\n    return node\n  }\n})\n\nconst filterChildNodes = [\n  'distantLight',\n  'pointLight',\n  'spotLight',\n  'mergeNode',\n  'FuncR',\n  'FuncG',\n  'FuncB',\n  'FuncA'\n]\n\nfilterChildNodes.forEach((child) => {\n  const name = utils.capitalize(child)\n  Filter[name] = class extends Effect {\n    constructor (node) {\n      super(nodeOrNew('fe' + name, node), node)\n    }\n  }\n})\n\nconst componentFuncs = [\n  'funcR',\n  'funcG',\n  'funcB',\n  'funcA'\n]\n\n// Add an update function for componentTransfer-children\ncomponentFuncs.forEach(function (c) {\n  const _class = Filter[utils.capitalize(c)]\n  const fn = wrapWithAttrCheck(function () {\n    return this.put(new _class())\n  })\n\n  Filter.ComponentTransferEffect.prototype[c] = fn\n})\n\nconst lights = [\n  'distantLight',\n  'pointLight',\n  'spotLight'\n]\n\n// Add light sources factories to lightining effects\nlights.forEach((light) => {\n  const _class = Filter[utils.capitalize(light)]\n  const fn = wrapWithAttrCheck(function () {\n    return this.put(new _class())\n  })\n\n  Filter.DiffuseLightingEffect.prototype[light] = fn\n  Filter.SpecularLightingEffect.prototype[light] = fn\n})\n\nextend(Filter.MergeEffect, {\n  mergeNode (_in) {\n    return this.put(new Filter.MergeNode()).attr('in', _in)\n  }\n})\n\n// add .filter function\nextend(Defs, {\n  // Define filter\n  filter: function (block) {\n    const filter = this.put(new Filter())\n\n    /* invoke passed block */\n    if (typeof block === 'function') { block.call(filter, filter) }\n\n    return filter\n  }\n})\n\nextend(Container, {\n  // Define filter on defs\n  filter: function (block) {\n    return this.defs().filter(block)\n  }\n})\n\nextend(Element, {\n  // Create filter element in defs and store reference\n  filterWith: function (block) {\n    const filter = block instanceof Filter\n      ? block\n      : this.defs().filter(block)\n\n    return this.attr('filter', filter)\n  },\n  // Remove filter\n  unfilter: function (remove) {\n    /* remove filter attribute */\n    return this.attr('filter', null)\n  },\n  filterer () {\n    return this.reference('filter')\n  }\n})\n\n// chaining\nconst chainingEffects = {\n  // Blend effect\n  blend: function (in2, mode) {\n    return this.parent() && this.parent().blend(this, in2, mode) // pass this as the first input\n  },\n  // ColorMatrix effect\n  colorMatrix: function (type, values) {\n    return this.parent() && this.parent().colorMatrix(type, values).in(this)\n  },\n  // ComponentTransfer effect\n  componentTransfer: function (components) {\n    return this.parent() && this.parent().componentTransfer(components).in(this)\n  },\n  // Composite effect\n  composite: function (in2, operator) {\n    return this.parent() && this.parent().composite(this, in2, operator) // pass this as the first input\n  },\n  // ConvolveMatrix effect\n  convolveMatrix: function (matrix) {\n    return this.parent() && this.parent().convolveMatrix(matrix).in(this)\n  },\n  // DiffuseLighting effect\n  diffuseLighting: function (surfaceScale, lightingColor, diffuseConstant, kernelUnitLength) {\n    return this.parent() && this.parent().diffuseLighting(surfaceScale, diffuseConstant, kernelUnitLength).in(this)\n  },\n  // DisplacementMap effect\n  displacementMap: function (in2, scale, xChannelSelector, yChannelSelector) {\n    return this.parent() && this.parent().displacementMap(this, in2, scale, xChannelSelector, yChannelSelector) // pass this as the first input\n  },\n  // DisplacementMap effect\n  dropShadow: function (x, y, stdDeviation) {\n    return this.parent() && this.parent().dropShadow(this, x, y, stdDeviation).in(this) // pass this as the first input\n  },\n  // Flood effect\n  flood: function (color, opacity) {\n    return this.parent() && this.parent().flood(color, opacity) // this effect dont have inputs\n  },\n  // Gaussian Blur effect\n  gaussianBlur: function (x, y) {\n    return this.parent() && this.parent().gaussianBlur(x, y).in(this)\n  },\n  // Image effect\n  image: function (src) {\n    return this.parent() && this.parent().image(src) // this effect dont have inputs\n  },\n  // Merge effect\n  merge: function (arg) {\n    arg = arg instanceof Array ? arg : [...arg]\n    return this.parent() && this.parent().merge(this, ...arg) // pass this as the first argument\n  },\n  // Morphology effect\n  morphology: function (operator, radius) {\n    return this.parent() && this.parent().morphology(operator, radius).in(this)\n  },\n  // Offset effect\n  offset: function (dx, dy) {\n    return this.parent() && this.parent().offset(dx, dy).in(this)\n  },\n  // SpecularLighting effect\n  specularLighting: function (surfaceScale, lightingColor, diffuseConstant, specularExponent, kernelUnitLength) {\n    return this.parent() && this.parent().specularLighting(surfaceScale, diffuseConstant, specularExponent, kernelUnitLength).in(this)\n  },\n  // Tile effect\n  tile: function () {\n    return this.parent() && this.parent().tile().in(this)\n  },\n  // Turbulence effect\n  turbulence: function (baseFrequency, numOctaves, seed, stitchTiles, type) {\n    return this.parent() && this.parent().turbulence(baseFrequency, numOctaves, seed, stitchTiles, type).in(this)\n  }\n}\n\nextend(Effect, chainingEffects)\n\n// Effect-specific extensions\nextend(Filter.MergeEffect, {\n  in: function (effect) {\n    if (effect instanceof Filter.MergeNode) {\n      this.add(effect, 0)\n    } else {\n      this.add(new Filter.MergeNode().in(effect), 0)\n    }\n\n    return this\n  }\n})\n\nextend([Filter.CompositeEffect, Filter.BlendEffect, Filter.DisplacementMapEffect], {\n  in2: function (effect) {\n    if (effect == null) {\n      const in2 = this.attr('in2')\n      const ref = this.parent() && this.parent().find(`[result=\"${in2}\"]`)[0]\n      return ref || in2\n    }\n    return this.attr('in2', effect)\n  }\n})\n\n// Presets\nFilter.filter = {\n  sepiatone: [\n    0.343, 0.669, 0.119, 0, 0,\n    0.249, 0.626, 0.130, 0, 0,\n    0.172, 0.334, 0.111, 0, 0,\n    0.000, 0.000, 0.000, 1, 0]\n}\n"],"names":["Filter","Element","constructor","node","nodeOrNew","$source","$sourceAlpha","$background","$backgroundAlpha","$fill","$stroke","$autoSetIn","put","element","i","super","attr","this","id","remove","targets","each","find","toString","Effect","result","in","effect","_in","parent","getAttrSetter","params","args","length","updateFunctions","blend","colorMatrix","composite","convolveMatrix","matrix","SVGArray","order","Math","sqrt","split","kernelMatrix","diffuseLighting","displacementMap","dropShadow","flood","gaussianBlur","x","y","image","src","ns","xlink","morphology","offset","specularLighting","tile","turbulence","forEach","name","utils","capitalize","fn","update","apply","prototype","wrapWithAttrCheck","call","unshift","merge","arrayOrFn","MergeEffect","Array","arguments","child","MergeNode","mergeNode","componentTransfer","components","ComponentTransferEffect","r","g","b","a","c","add","toUpperCase","_class","light","DiffuseLightingEffect","SpecularLightingEffect","Defs","filter","block","Container","defs","filterWith","unfilter","filterer","reference","chainingEffects","in2","mode","type","values","operator","surfaceScale","lightingColor","diffuseConstant","kernelUnitLength","scale","xChannelSelector","yChannelSelector","stdDeviation","color","opacity","arg","radius","dx","dy","specularExponent","baseFrequency","numOctaves","seed","stitchTiles","CompositeEffect","BlendEffect","DisplacementMapEffect","sepiatone"],"mappings":"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"}