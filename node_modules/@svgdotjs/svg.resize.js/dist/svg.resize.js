/*!
* @svgdotjs/svg.resize.js - An extension for svg.js which allows to resize elements which are selected
* @version 2.0.4
* https://github.com/svgdotjs/svg.resize.js
*
* @copyright [object Object]
* @license MIT
*
* BUILT: Fri Sep 13 2024 12:43:14 GMT+0200 (Central European Summer Time)
*/
;
import { extend, Element, Polygon, Polyline, Line, G, getWindow, on, Box, Matrix, Point, off } from "@svgdotjs/svg.js";
/*!
* @svgdotjs/svg.select.js - An extension of svg.js which allows to select elements with mouse
* @version 4.0.1
* https://github.com/svgdotjs/svg.select.js
*
* @copyright Ulrich-Matthias SchÃ¤fer
* @license MIT
*
* BUILT: Mon Jul 01 2024 15:04:42 GMT+0200 (Central European Summer Time)
*/
function getMoseDownFunc(eventName, el, points, index = null) {
  return function(ev) {
    ev.preventDefault();
    ev.stopPropagation();
    var x = ev.pageX || ev.touches[0].pageX;
    var y = ev.pageY || ev.touches[0].pageY;
    el.fire(eventName, { x, y, event: ev, index, points });
  };
}
function transformPoint([x, y], { a, b, c, d, e, f }) {
  return [x * a + y * c + e, x * b + y * d + f];
}
class SelectHandler {
  constructor(el) {
    this.el = el;
    el.remember("_selectHandler", this);
    this.selection = new G();
    this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"];
    this.mutationHandler = this.mutationHandler.bind(this);
    const win = getWindow();
    this.observer = new win.MutationObserver(this.mutationHandler);
  }
  init(options) {
    this.createHandle = options.createHandle || this.createHandleFn;
    this.createRot = options.createRot || this.createRotFn;
    this.updateHandle = options.updateHandle || this.updateHandleFn;
    this.updateRot = options.updateRot || this.updateRotFn;
    this.el.root().put(this.selection);
    this.updatePoints();
    this.createSelection();
    this.createResizeHandles();
    this.updateResizeHandles();
    this.createRotationHandle();
    this.updateRotationHandle();
    this.observer.observe(this.el.node, { attributes: true });
  }
  active(val, options) {
    if (!val) {
      this.selection.clear().remove();
      this.observer.disconnect();
      return;
    }
    this.init(options);
  }
  createSelection() {
    this.selection.polygon(this.handlePoints).addClass("svg_select_shape");
  }
  updateSelection() {
    this.selection.get(0).plot(this.handlePoints);
  }
  createResizeHandles() {
    this.handlePoints.forEach((p, index, arr) => {
      const name = this.order[index];
      this.createHandle.call(this, this.selection, p, index, arr, name);
      this.selection.get(index + 1).addClass("svg_select_handle svg_select_handle_" + name).on("mousedown.selection touchstart.selection", getMoseDownFunc(name, this.el, this.handlePoints, index));
    });
  }
  createHandleFn(group) {
    group.polyline();
  }
  updateHandleFn(shape, point, index, arr) {
    const before = arr.at(index - 1);
    const next = arr[(index + 1) % arr.length];
    const p = point;
    const diff1 = [p[0] - before[0], p[1] - before[1]];
    const diff2 = [p[0] - next[0], p[1] - next[1]];
    const len1 = Math.sqrt(diff1[0] * diff1[0] + diff1[1] * diff1[1]);
    const len2 = Math.sqrt(diff2[0] * diff2[0] + diff2[1] * diff2[1]);
    const normalized1 = [diff1[0] / len1, diff1[1] / len1];
    const normalized2 = [diff2[0] / len2, diff2[1] / len2];
    const beforeNew = [p[0] - normalized1[0] * 10, p[1] - normalized1[1] * 10];
    const nextNew = [p[0] - normalized2[0] * 10, p[1] - normalized2[1] * 10];
    shape.plot([beforeNew, p, nextNew]);
  }
  updateResizeHandles() {
    this.handlePoints.forEach((p, index, arr) => {
      const name = this.order[index];
      this.updateHandle.call(this, this.selection.get(index + 1), p, index, arr, name);
    });
  }
  createRotFn(group) {
    group.line();
    group.circle(5);
  }
  getPoint(name) {
    return this.handlePoints[this.order.indexOf(name)];
  }
  getPointHandle(name) {
    return this.selection.get(this.order.indexOf(name) + 1);
  }
  updateRotFn(group, rotPoint) {
    const topPoint = this.getPoint("t");
    group.get(0).plot(topPoint[0], topPoint[1], rotPoint[0], rotPoint[1]);
    group.get(1).center(rotPoint[0], rotPoint[1]);
  }
  createRotationHandle() {
    const handle = this.selection.group().addClass("svg_select_handle_rot").on("mousedown.selection touchstart.selection", getMoseDownFunc("rot", this.el, this.handlePoints));
    this.createRot.call(this, handle);
  }
  updateRotationHandle() {
    const group = this.selection.findOne("g.svg_select_handle_rot");
    this.updateRot(group, this.rotationPoint, this.handlePoints);
  }
  // gets new bounding box points and transform them into the elements space
  updatePoints() {
    const bbox = this.el.bbox();
    const fromShapeToUiMatrix = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.handlePoints = this.getHandlePoints(bbox).map((p) => transformPoint(p, fromShapeToUiMatrix));
    this.rotationPoint = transformPoint(this.getRotationPoint(bbox), fromShapeToUiMatrix);
  }
  // A collection of all the points we need to draw our ui
  getHandlePoints({ x, x2, y, y2, cx, cy } = this.el.bbox()) {
    return [
      [x, y],
      [cx, y],
      [x2, y],
      [x2, cy],
      [x2, y2],
      [cx, y2],
      [x, y2],
      [x, cy]
    ];
  }
  // A collection of all the points we need to draw our ui
  getRotationPoint({ y, cx } = this.el.bbox()) {
    return [cx, y - 20];
  }
  mutationHandler() {
    this.updatePoints();
    this.updateSelection();
    this.updateResizeHandles();
    this.updateRotationHandle();
  }
}
class PointSelectHandler {
  constructor(el) {
    this.el = el;
    el.remember("_pointSelectHandler", this);
    this.selection = new G();
    this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"];
    this.mutationHandler = this.mutationHandler.bind(this);
    const win = getWindow();
    this.observer = new win.MutationObserver(this.mutationHandler);
  }
  init(options) {
    this.createHandle = options.createHandle || this.createHandleFn;
    this.updateHandle = options.updateHandle || this.updateHandleFn;
    this.el.root().put(this.selection);
    this.updatePoints();
    this.createSelection();
    this.createPointHandles();
    this.updatePointHandles();
    this.observer.observe(this.el.node, { attributes: true });
  }
  active(val, options) {
    if (!val) {
      this.selection.clear().remove();
      this.observer.disconnect();
      return;
    }
    this.init(options);
  }
  createSelection() {
    this.selection.polygon(this.points).addClass("svg_select_shape_pointSelect");
  }
  updateSelection() {
    this.selection.get(0).plot(this.points);
  }
  createPointHandles() {
    this.points.forEach((p, index, arr) => {
      this.createHandle.call(this, this.selection, p, index, arr);
      this.selection.get(index + 1).addClass("svg_select_handle_point").on("mousedown.selection touchstart.selection", getMoseDownFunc("point", this.el, this.points, index));
    });
  }
  createHandleFn(group) {
    group.circle(5);
  }
  updateHandleFn(shape, point) {
    shape.center(point[0], point[1]);
  }
  updatePointHandles() {
    this.points.forEach((p, index, arr) => {
      this.updateHandle.call(this, this.selection.get(index + 1), p, index, arr);
    });
  }
  // gets new bounding box points and transform them into the elements space
  updatePoints() {
    const fromShapeToUiMatrix = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.points = this.el.array().map((p) => transformPoint(p, fromShapeToUiMatrix));
  }
  mutationHandler() {
    this.updatePoints();
    this.updateSelection();
    this.updatePointHandles();
  }
}
const getSelectFn = (handleClass) => {
  return function(enabled = true, options = {}) {
    if (typeof enabled === "object") {
      options = enabled;
      enabled = true;
    }
    let selectHandler = this.remember("_" + handleClass.name);
    if (!selectHandler) {
      if (enabled.prototype instanceof SelectHandler) {
        selectHandler = new enabled(this);
        enabled = true;
      } else {
        selectHandler = new handleClass(this);
      }
      this.remember("_" + handleClass.name, selectHandler);
    }
    selectHandler.active(enabled, options);
    return this;
  };
};
extend(Element, {
  select: getSelectFn(SelectHandler)
});
extend([Polygon, Polyline, Line], {
  pointSelect: getSelectFn(PointSelectHandler)
});
const getCoordsFromEvent = (ev) => {
  if (ev.changedTouches) {
    ev = ev.changedTouches[0];
  }
  return { x: ev.clientX, y: ev.clientY };
};
const maxBoxFromPoints = (points) => {
  let x = Infinity;
  let y = Infinity;
  let x2 = -Infinity;
  let y2 = -Infinity;
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    x = Math.min(x, p[0]);
    y = Math.min(y, p[1]);
    x2 = Math.max(x2, p[0]);
    y2 = Math.max(y2, p[1]);
  }
  return new Box(x, y, x2 - x, y2 - y);
};
function scaleBox(box, origin, scale) {
  const points = [
    [box.x, box.y],
    [box.x + box.width, box.y],
    [box.x + box.width, box.y + box.height],
    [box.x, box.y + box.height]
  ];
  const newPoints = points.map(([x, y]) => {
    const translatedX = x - origin[0];
    const translatedY = y - origin[1];
    const scaledX = translatedX * scale;
    const scaledY = translatedY * scale;
    return [scaledX + origin[0], scaledY + origin[1]];
  });
  return maxBoxFromPoints(newPoints);
}
class ResizeHandler {
  constructor(el) {
    this.el = el;
    el.remember("_ResizeHandler", this);
    this.lastCoordinates = null;
    this.eventType = "";
    this.lastEvent = null;
    this.handleResize = this.handleResize.bind(this);
    this.resize = this.resize.bind(this);
    this.endResize = this.endResize.bind(this);
    this.rotate = this.rotate.bind(this);
    this.movePoint = this.movePoint.bind(this);
  }
  active(value, options) {
    this.preserveAspectRatio = options.preserveAspectRatio ?? false;
    this.aroundCenter = options.aroundCenter ?? false;
    this.grid = options.grid ?? 0;
    this.degree = options.degree ?? 0;
    this.el.off(".resize");
    if (!value) return;
    this.el.on(
      [
        "lt.resize",
        "rt.resize",
        "rb.resize",
        "lb.resize",
        "t.resize",
        "r.resize",
        "b.resize",
        "l.resize",
        "rot.resize",
        "point.resize"
      ],
      this.handleResize
    );
    if (this.lastEvent) {
      if (this.eventType === "rot") {
        this.rotate(this.lastEvent);
      } else if (this.eventType === "point") {
        this.movePoint(this.lastEvent);
      } else {
        this.resize(this.lastEvent);
      }
    }
  }
  // This is called when a user clicks on one of the resize points
  handleResize(e) {
    this.eventType = e.type;
    const { event, index, points } = e.detail;
    const isMouse = !event.type.indexOf("mouse");
    if (isMouse && (event.which || event.buttons) !== 1) {
      return;
    }
    if (this.el.dispatch("beforeresize", { event: e, handler: this }).defaultPrevented) {
      return;
    }
    this.box = this.el.bbox();
    this.startPoint = this.el.point(getCoordsFromEvent(event));
    this.index = index;
    this.points = points.slice();
    const eventMove = (isMouse ? "mousemove" : "touchmove") + ".resize";
    const eventEnd = (isMouse ? "mouseup" : "touchcancel.resize touchend") + ".resize";
    if (e.type === "point") {
      on(window, eventMove, this.movePoint);
    } else if (e.type === "rot") {
      on(window, eventMove, this.rotate);
    } else {
      on(window, eventMove, this.resize);
    }
    on(window, eventEnd, this.endResize);
  }
  resize(e) {
    this.lastEvent = e;
    const endPoint = this.snapToGrid(this.el.point(getCoordsFromEvent(e)));
    let dx = endPoint.x - this.startPoint.x;
    let dy = endPoint.y - this.startPoint.y;
    if (this.preserveAspectRatio && this.aroundCenter) {
      dx *= 2;
      dy *= 2;
    }
    const x = this.box.x + dx;
    const y = this.box.y + dy;
    const x2 = this.box.x2 + dx;
    const y2 = this.box.y2 + dy;
    let box = new Box(this.box);
    if (this.eventType.includes("l")) {
      box.x = Math.min(x, this.box.x2);
      box.x2 = Math.max(x, this.box.x2);
    }
    if (this.eventType.includes("r")) {
      box.x = Math.min(x2, this.box.x);
      box.x2 = Math.max(x2, this.box.x);
    }
    if (this.eventType.includes("t")) {
      box.y = Math.min(y, this.box.y2);
      box.y2 = Math.max(y, this.box.y2);
    }
    if (this.eventType.includes("b")) {
      box.y = Math.min(y2, this.box.y);
      box.y2 = Math.max(y2, this.box.y);
    }
    box.width = box.x2 - box.x;
    box.height = box.y2 - box.y;
    if (this.preserveAspectRatio) {
      const scaleX = box.width / this.box.width;
      const scaleY = box.height / this.box.height;
      const order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l"];
      const origin = (order.indexOf(this.eventType) + 4) % order.length;
      const constantPoint = this.aroundCenter ? [this.box.cx, this.box.cy] : this.points[origin];
      let scale = this.eventType.includes("t") || this.eventType.includes("b") ? scaleY : scaleX;
      scale = this.eventType.length === 2 ? Math.max(scaleX, scaleY) : scale;
      box = scaleBox(this.box, constantPoint, scale);
    }
    if (this.el.dispatch("resize", {
      box: new Box(box),
      angle: 0,
      eventType: this.eventType,
      event: e,
      handler: this
    }).defaultPrevented) {
      return;
    }
    this.el.size(box.width, box.height).move(box.x, box.y);
  }
  movePoint(e) {
    this.lastEvent = e;
    const { x, y } = this.snapToGrid(this.el.point(getCoordsFromEvent(e)));
    const pointArr = this.el.array().slice();
    pointArr[this.index] = [x, y];
    if (this.el.dispatch("resize", {
      box: maxBoxFromPoints(pointArr),
      angle: 0,
      eventType: this.eventType,
      event: e,
      handler: this
    }).defaultPrevented) {
      return;
    }
    this.el.plot(pointArr);
  }
  rotate(e) {
    this.lastEvent = e;
    const startPoint = this.startPoint;
    const endPoint = this.el.point(getCoordsFromEvent(e));
    const { cx, cy } = this.box;
    const dx1 = startPoint.x - cx;
    const dy1 = startPoint.y - cy;
    const dx2 = endPoint.x - cx;
    const dy2 = endPoint.y - cy;
    const c = Math.sqrt(dx1 * dx1 + dy1 * dy1) * Math.sqrt(dx2 * dx2 + dy2 * dy2);
    if (c === 0) {
      return;
    }
    let angle = Math.acos((dx1 * dx2 + dy1 * dy2) / c) / Math.PI * 180;
    if (!angle) return;
    if (endPoint.x < startPoint.x) {
      angle = -angle;
    }
    const matrix = new Matrix(this.el);
    const { x: ox, y: oy } = new Point(cx, cy).transformO(matrix);
    const { rotate } = matrix.decompose();
    const resultAngle = this.snapToAngle(rotate + angle) - rotate;
    if (this.el.dispatch("resize", {
      box: this.box,
      angle: resultAngle,
      eventType: this.eventType,
      event: e,
      handler: this
    }).defaultPrevented) {
      return;
    }
    this.el.transform(matrix.rotateO(resultAngle, ox, oy));
  }
  endResize(ev) {
    if (this.eventType !== "rot" && this.eventType !== "point") {
      this.resize(ev);
    }
    this.lastEvent = null;
    this.eventType = "";
    off(window, "mousemove.resize touchmove.resize");
    off(window, "mouseup.resize touchend.resize");
  }
  snapToGrid(point) {
    if (this.grid) {
      point.x = Math.round(point.x / this.grid) * this.grid;
      point.y = Math.round(point.y / this.grid) * this.grid;
    }
    return point;
  }
  snapToAngle(angle) {
    if (this.degree) {
      angle = Math.round(angle / this.degree) * this.degree;
    }
    return angle;
  }
}
extend(Element, {
  // Resize element with mouse
  resize: function(enabled = true, options = {}) {
    if (typeof enabled === "object") {
      options = enabled;
      enabled = true;
    }
    let resizeHandler = this.remember("_ResizeHandler");
    if (!resizeHandler) {
      if (enabled.prototype instanceof ResizeHandler) {
        resizeHandler = new enabled(this);
        enabled = true;
      } else {
        resizeHandler = new ResizeHandler(this);
      }
      this.remember("_resizeHandler", resizeHandler);
    }
    resizeHandler.active(enabled, options);
    return this;
  }
});
export {
  ResizeHandler
};
//# sourceMappingURL=svg.resize.js.map
