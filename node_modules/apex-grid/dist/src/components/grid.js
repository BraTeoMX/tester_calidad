var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html, nothing } from 'lit';
import { ContextProvider } from '@lit-labs/context';
import { eventOptions, property, query, queryAll, state } from 'lit/decorators.js';
import { styleMap } from 'lit/directives/style-map.js';
import { GRID_TAG } from '../internal/tags.js';
import { StateController, gridStateContext } from '../controllers/state.js';
import { DataOperationsController } from '../controllers/data-operation.js';
import { GridDOMController } from '../controllers/dom.js';
import { EventEmitterBase } from '../internal/mixins/event-emitter.js';
import { watch } from '../internal/watch.js';
import { DEFAULT_COLUMN_CONFIG, PIPELINE } from '../internal/constants.js';
import { asArray, autoGenerateColumns, getFilterOperandsFor } from '../internal/utils.js';
import { registerComponent } from '../internal/register.js';
import { styles as bootstrap } from '../styles/grid/themes/light/grid.bootstrap-styles.css.js';
import { styles as fluent } from '../styles/grid/themes/light/grid.fluent-styles.css.js';
import { styles as indigo } from '../styles/grid/themes/light/grid.indigo-styles.css.js';
import { styles as material } from '../styles/grid/themes/light/grid.material-styles.css.js';
import ApexVirtualizer from './virtualizer.js';
import ApexGridHeaderRow from './header-row.js';
import ApexGridRow from './row.js';
import ApexGridCell from './cell.js';
import ApexFilterRow from './filter-row.js';
import { themes } from 'igniteui-webcomponents/theming/theming-decorator.js';
import { defineComponents, IgcButtonComponent, IgcChipComponent, IgcDropdownComponent, IgcInputComponent, IgcIconComponent, } from 'igniteui-webcomponents';
/**
 * Apex grid is a web component for displaying data in a tabular format quick and easy.
 *
 * Out of the box it provides row virtualization, sort and filter operations (client and server side),
 * the ability to template cells and headers and column hiding.
 *
 * @element apex-grid
 *
 * @fires sorting - Emitted when sorting is initiated through the UI.
 * @fires sorted - Emitted when a sort operation initiated through the UI has completed.
 * @fires filtering - Emitted when filtering is initiated through the UI.
 * @fires filtered - Emitted when a filter operation initiated through the UI has completed.
 *
 */
let ApexGrid = class ApexGrid extends EventEmitterBase {
    constructor() {
        super(...arguments);
        this.stateController = new StateController(this);
        this.DOM = new GridDOMController(this, this.stateController);
        this.dataController = new DataOperationsController(this);
        this.stateProvider = new ContextProvider(this, {
            context: gridStateContext,
            initialValue: this.stateController,
        });
        this.dataState = [];
        /** Column configuration for the grid. */
        this.columns = [];
        /** The data source for the grid. */
        this.data = [];
        /**
         * Whether the grid will try to "resolve" its column configuration based on the passed
         * data source.
         *
         * @remarks
         * This is usually executed on initial rendering in the DOM. It depends on having an existing data source
         * to infer the column configuration for the grid.
         * Passing an empty data source or having a late bound data source (such as a HTTP request) will usually
         * result in empty column configuration for the grid.
         *
         * This property is ignored if any existing column configuration already exists in the grid.
         *
         * In a scenario where you want to bind a new data source and still keep the auto-generation behavior,
         * make sure to reset the column collection of the grid before passing in the new data source.
         *
         * @example
         * ```typescript
         * // assuming autoGenerate is set to true
         * grid.columns = [];
         * grid.data = [...];
         * ```
         *
         * @attr auto-generate
         */
        this.autoGenerate = false;
        /** Sort configuration property for the grid. */
        this.sortConfiguration = {
            multiple: true,
            triState: true,
        };
    }
    static get is() {
        return GRID_TAG;
    }
    static register() {
        registerComponent(this, [ApexVirtualizer, ApexGridRow, ApexGridHeaderRow, ApexFilterRow]);
        defineComponents(IgcButtonComponent, IgcChipComponent, IgcInputComponent, IgcDropdownComponent, IgcIconComponent);
    }
    /**
     * Set the sort state for the grid.
     */
    set sortExpressions(expressions) {
        if (expressions.length) {
            this.sort(expressions);
        }
    }
    /**
     * Get the sort state for the grid.
     */
    get sortExpressions() {
        return Array.from(this.stateController.sorting.state.values());
    }
    /**
     * Set the filter state for the grid.
     */
    set filterExpressions(expressions) {
        if (expressions.length) {
            this.filter(expressions);
        }
    }
    /**
     * Get the filter state for the grid.
     */
    get filterExpressions() {
        return this.stateController.filtering.state.values.reduce((prev, curr) => [...prev, ...curr.all], []);
    }
    /**
     * Returns the collection of rendered row elements in the grid.
     *
     * @remarks
     * Since the grid has virtualization, this property returns only the currently rendered
     * chunk of elements in the DOM.
     */
    get rows() {
        return Array.from(this._rows);
    }
    /**
     * Returns the state of the data source after sort/filter operations
     * have been applied.
     */
    get dataView() {
        return this.dataState;
    }
    /**
     * The total number of items in the {@link ApexGrid.dataView} collection.
     */
    get totalItems() {
        return this.dataState.length;
    }
    watchColumns(_, newConfig = []) {
        this.columns = newConfig.map(config => ({ ...DEFAULT_COLUMN_CONFIG, ...config }));
    }
    dataChanged() {
        this.dataState = structuredClone(this.data);
        autoGenerateColumns(this);
        if (this.hasUpdated) {
            this.pipeline();
        }
    }
    async pipeline() {
        this.dataState = await this.dataController.apply(structuredClone(this.data), this.stateController);
    }
    /**
     * Performs a filter operation in the grid based on the passed expression(s).
     */
    filter(config) {
        this.stateController.filtering.filter(asArray(config).map(each => typeof each.condition === 'string'
            ? // XXX: Types
                Object.assign(each, {
                    condition: getFilterOperandsFor(this.getColumn(each.key))[each.condition],
                })
            : each));
    }
    /**
     * Performs a sort operation in the grid based on the passed expression(s).
     */
    sort(expressions) {
        this.stateController.sorting.sort(expressions);
    }
    /**
     * Resets the current sort state of the control.
     */
    clearSort(key) {
        this.stateController.sorting.reset(key);
        this.requestUpdate(PIPELINE);
    }
    /**
     * Resets the current filter state of the control.
     */
    clearFilter(key) {
        this.stateController.filtering.reset(key);
        this.requestUpdate(PIPELINE);
    }
    /**
     * Returns a {@link ColumnConfiguration} for a given column.
     */
    getColumn(id) {
        return typeof id === 'number'
            ? this.columns.at(id)
            : this.columns.find(({ key }) => key === id);
    }
    /**
     * Updates the column configuration of the grid.
     */
    updateColumns(columns) {
        asArray(columns).forEach(column => {
            const idx = this.columns.findIndex(original => original.key === column.key);
            this.columns[idx] = { ...this.columns[idx], ...column };
        });
        this.requestUpdate(PIPELINE);
    }
    bodyClickHandler(event) {
        const target = event.composedPath().find(el => el instanceof ApexGridCell);
        if (target) {
            this.stateController.active = {
                column: target.column.key,
                row: target.row.index,
            };
        }
    }
    bodyKeydownHandler(event) {
        if (this.scrollContainer.isSameNode(event.target)) {
            this.stateController.navigation.navigate(event);
        }
    }
    renderHeaderRow() {
        return html `<apex-grid-header-row
      style=${styleMap(this.DOM.columnSizes)}
      .columns=${this.columns}
    ></apex-grid-header-row>`;
    }
    renderBody() {
        return html `
      <apex-virtualizer
        .items=${this.dataState}
        .renderItem=${this.DOM.rowRenderer}
        @click=${this.bodyClickHandler}
        @keydown=${this.bodyKeydownHandler}
      ></apex-virtualizer>
    `;
    }
    renderFilterRow() {
        return this.columns.some(column => column.filter)
            ? html `<apex-filter-row style=${styleMap(this.DOM.columnSizes)}></apex-filter-row>`
            : nothing;
    }
    render() {
        return html ` ${this.stateController.resizing.renderIndicator()} ${this.renderHeaderRow()}
    ${this.renderFilterRow()} ${this.renderBody()}`;
    }
};
ApexGrid.styles = bootstrap;
__decorate([
    query(ApexVirtualizer.is)
], ApexGrid.prototype, "scrollContainer", void 0);
__decorate([
    query(ApexGridHeaderRow.is)
], ApexGrid.prototype, "headerRow", void 0);
__decorate([
    query(ApexFilterRow.is)
], ApexGrid.prototype, "filterRow", void 0);
__decorate([
    state()
], ApexGrid.prototype, "dataState", void 0);
__decorate([
    queryAll(ApexGridRow.is)
], ApexGrid.prototype, "_rows", void 0);
__decorate([
    property({ attribute: false })
], ApexGrid.prototype, "columns", void 0);
__decorate([
    property({ attribute: false })
], ApexGrid.prototype, "data", void 0);
__decorate([
    property({ type: Boolean, attribute: 'auto-generate' })
], ApexGrid.prototype, "autoGenerate", void 0);
__decorate([
    property({ attribute: false })
], ApexGrid.prototype, "sortConfiguration", void 0);
__decorate([
    property({ attribute: false })
], ApexGrid.prototype, "dataPipelineConfiguration", void 0);
__decorate([
    property({ attribute: false })
], ApexGrid.prototype, "sortExpressions", null);
__decorate([
    property({ attribute: false })
], ApexGrid.prototype, "filterExpressions", null);
__decorate([
    watch('columns')
], ApexGrid.prototype, "watchColumns", null);
__decorate([
    watch('data')
], ApexGrid.prototype, "dataChanged", null);
__decorate([
    watch(PIPELINE)
], ApexGrid.prototype, "pipeline", null);
__decorate([
    eventOptions({ capture: true })
], ApexGrid.prototype, "bodyClickHandler", null);
ApexGrid = __decorate([
    themes({
        bootstrap,
        fluent,
        indigo,
        material,
    })
], ApexGrid);
export { ApexGrid };
//# sourceMappingURL=grid.js.map