export class FilterExpressionTree {
    constructor(key) {
        this.key = key;
        this.operands = [];
    }
    get empty() {
        return this.operands.length < 1;
    }
    get length() {
        return this.operands.length;
    }
    get all() {
        return Array.from(this.iterator());
    }
    get ands() {
        return this.operands.filter(each => each.criteria === 'and');
    }
    get ors() {
        return this.operands.filter(each => each.criteria === 'or');
    }
    has(expression) {
        return this.operands.includes(expression);
    }
    add(expression) {
        if (!expression.criteria) {
            expression.criteria = 'and';
        }
        if (this.operands.includes(expression)) {
            return this;
        }
        this.operands.push(expression);
        return this;
    }
    remove(expression) {
        this.operands = this.operands.filter(each => each !== expression);
        return this;
    }
    *iterator() {
        for (const operand of this.operands) {
            yield operand;
        }
    }
    [Symbol.iterator]() {
        return this.iterator();
    }
}
//# sourceMappingURL=tree.js.map