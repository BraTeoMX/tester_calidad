{"version":3,"file":"sort.js","sourceRoot":"","sources":["../../../src/operations/sort.ts"],"names":[],"mappings":"AAAA,OAAO,aAAa,MAAM,WAAW,CAAC;AAGtC,MAAM,CAAC,OAAO,OAAO,iBAAqB,SAAQ,aAAgB;IAAlE;;QACY,YAAO,GAAG,IAAI,GAAG,CACzB,MAAM,CAAC,OAAO,CAAC;YACb,SAAS,EAAE,CAAC;YACZ,UAAU,EAAE,CAAC,CAAC;SACf,CAAC,CACH,CAAC;IAuCJ,CAAC;IArCW,aAAa,CAAI,KAAQ,EAAE,MAAS;QAC5C,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,OAAO,MAAM,KAAK,QAAQ,EAAE;YAC3D,OAAO,KAAK,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;SACpC;QACD,OAAO,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACtD,CAAC;IAES,cAAc,CAAC,KAAQ,EAAE,MAAS,EAAE,UAA6B;;QACzE,MAAM,EAAE,SAAS,EAAE,GAAG,EAAE,aAAa,EAAE,QAAQ,EAAE,GAAG,UAAU,CAAC;QAE/D,MAAM,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,GAAG,CAAC,EAAE,aAAa,CAAC,CAAC;QACzE,MAAM,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,GAAG,CAAC,EAAE,aAAa,CAAC,CAAC;QAE1E,8BAA8B;QAC9B,OAAO,CACL,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,CAAE,GAAG,CAAC,MAAA,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAG,CAAQ,EAAE,CAAQ,CAAC,mCAAI,IAAI,CAAC,aAAa,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAC5F,CAAC;IACJ,CAAC;IAEM,KAAK,CAAC,IAAS,EAAE,KAAmB;QACzC,MAAM,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,EAC5C,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC;QAE9B,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;YACjB,IAAI,CAAC,GAAG,CAAC,EACP,MAAM,GAAG,CAAC,CAAC;YAEb,OAAO,CAAC,GAAG,MAAM,IAAI,CAAC,MAAM,EAAE;gBAC5B,MAAM,GAAG,IAAI,CAAC,cAAc,CAAC,CAAC,EAAE,CAAC,EAAE,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;gBACnD,CAAC,EAAE,CAAC;aACL;YAED,OAAO,MAAM,CAAC;QAChB,CAAC,CAAC,CAAC;QAEH,OAAO,IAAI,CAAC;IACd,CAAC;CACF","sourcesContent":["import DataOperation from './base.js';\nimport type { SortExpression, SortState } from './sort/types.js';\n\nexport default class SortDataOperation<T> extends DataOperation<T> {\n  protected orderBy = new Map(\n    Object.entries({\n      ascending: 1,\n      descending: -1,\n    }),\n  );\n\n  protected compareValues<U>(first: U, second: U) {\n    if (typeof first === 'string' && typeof second === 'string') {\n      return first.localeCompare(second);\n    }\n    return first > second ? 1 : first < second ? -1 : 0;\n  }\n\n  protected compareObjects(first: T, second: T, expression: SortExpression<T>) {\n    const { direction, key, caseSensitive, comparer } = expression;\n\n    const a = this.resolveCase(this.resolveValue(first, key), caseSensitive);\n    const b = this.resolveCase(this.resolveValue(second, key), caseSensitive);\n\n    // TODO: Remove casting as any\n    return (\n      this.orderBy.get(direction)! * (comparer?.(a as any, b as any) ?? this.compareValues(a, b))\n    );\n  }\n\n  public apply(data: T[], state: SortState<T>) {\n    const expressions = Array.from(state.values()),\n      length = expressions.length;\n\n    data.sort((a, b) => {\n      let i = 0,\n        result = 0;\n\n      while (i < length && !result) {\n        result = this.compareObjects(a, b, expressions[i]);\n        i++;\n      }\n\n      return result;\n    });\n\n    return data;\n  }\n}\n"]}